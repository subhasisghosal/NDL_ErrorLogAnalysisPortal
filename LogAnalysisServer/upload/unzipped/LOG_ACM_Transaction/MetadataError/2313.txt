{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/17631","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/17631","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/17632","fieldValue":"Ma, Wan-Chun"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/17632","fieldValue":"Sorkine-Hornung, Olga"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/17632","fieldValue":" We propose a novel approach to digital character animation, combining the benefits of tangible input devices and sophisticated rig animation algorithms. A symbiotic software and hardware approach facilitates the animation process for novice and expert users alike. We overcome limitations inherent to all previous tangible devices by allowing users to directly control complex rigs using only a small set (5-10) of physical controls. This avoids oversimplification of the pose space and excessively bulky device configurations. Our algorithm derives a small device configuration from complex character rigs, often containing hundreds of degrees of freedom, and a set of sparse sample poses. Importantly, only the most influential degrees of freedom are controlled directly, yet detailed motion is preserved based on a pose interpolation technique. We designed a modular collection of joints and splitters, which can be assembled to represent a wide variety of skeletons. Each joint piece combines a universal joint and two twisting elements, allowing to accurately sense its configuration. The mechanical design provides a smooth inverse kinematics-like user experience and is not prone to gimbal locking. We integrate our method with the professional 3D software Autodesk $Maya^Â®$ and discuss a variety of results created with characters available online. Comparative user experiments show significant improvements over the closest state-of-the-art in terms of accuracy and time in a keyframe posing task."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/17632","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/17632","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/2667","fieldValue":" We study algorithms for spectral graph sparsification. The input is a graph G with n vertices and m edges, and the output is a sparse graph &Gtilde; that approximates G in an algebraic sense. Concretely, for all vectors x and any &epsi; > 0, the graph &Gtilde; satisfies (1-&epsi; $)x^T $L_Gx â\u2030¤ xT L&Gtilde;x â\u2030¤ (1+&epsi;)xT LGx, where LG$ and &Gtilde; are the Laplacians of G and &Gtilde; respectively. The first contribution of this article applies to all existing sparsification algorithms that rely on solving solving linear systems on graph Laplacians. These algorithms are the fastest known to date. Specifically, we show that less precision is required in the solution of the linear systems, leading to speedups by an O(log n) factor. We also present faster sparsification algorithms for slightly dense graphs: â\u20AC\u201D An O(mlog n) time algorithm that generates a sparsifier with O(nlog 3n\/&epsi;2) edges. â\u20AC\u201D An O(mlog log n) time algorithm for graphs with more than nlog 5nlog log n edges. â\u20AC\u201D An O(m) algorithm for graphs with more than nlog 10n edges. â\u20AC\u201D An O(m) algorithm for unweighted graphs with more than nlog 8$n edges. These bounds hold up to factors that are in O(poly(log log n)) and are conjectured to be removable."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/2667","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/2667","fieldValue":"ACM"}