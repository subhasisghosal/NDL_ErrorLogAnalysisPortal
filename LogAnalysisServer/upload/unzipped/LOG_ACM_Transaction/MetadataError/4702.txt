{"fieldName":"dc.subject","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/25140","fieldValue":"DDDAS"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/25140","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/25140","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/25141","fieldValue":" Network simulation is commonly used to evaluate the performance of distributed systems, but these approaches do not account for the performance impact that protocol execution on nodes has on performance, which can be significant. We provide a methodology to extract from real devices models of communication software execution that can be used to extend network simulators to improve their accuracy. The models are obtained by instrumenting the target devices to obtain the events necessary to describe software execution. We specify which events must be captured, how to capture them, and how to transform the event traces into models that can be used to extend network simulators. The obtained models are based on high-level abstractions that can be used to describe the execution of a wide range of communication software, and the design principles to extend network simulators are not restricted to any specific network simulator. The same model of communication software execution can be used without modification in all discrete event-based network simulators that are extended according to our principles. The models are represented in a human-readable format that is suitable for modification and can therefore be used to predict how software modifications impact performance. We evaluate our models with two proof-of-concept extensions of Ns-3 that execute the models of two modern smartphones: the Google Nexus One (GN1) and the Nokia N900. We measure the accuracy of our models by comparing results from real experiments with those from simulations with our models and analyze the simulation overhead of our approach."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/25141","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/25141","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/25142","fieldValue":" The design of high-performance computing architectures requires performance analysis of large-scale parallel applications to derive various parameters concerning hardware design and software development. The process of performance analysis and benchmarking an application can be done in several ways with varying degrees of fidelity. One of the most cost-effective ways is to do a coarse-grained study of large-scale parallel applications through the use of program skeletons. The concept of a â\u20ACœprogram skeletonâ\u20AC? that we discuss in this article is an abstracted program that is derived from a larger program where source code that is determined to be irrelevant is removed for the purposes of the skeleton. In this work, we develop a semiautomatic approach for extracting program skeletons based on compiler program analysis. We demonstrate correctness of our skeleton extraction process by comparing details from communication traces, as well as show the performance speedup of using skeletons by running simulations in the SST\/macro simulator."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/25142","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/25142","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/25143","fieldValue":"Yoginath, Srikanth B"}