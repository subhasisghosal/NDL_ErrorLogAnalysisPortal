{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/2418","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/2418","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/15023","fieldValue":" This paper describes a general-purpose programming technique, called Simulation of Simplicity, that can be used to cope with degenerate input data for geometric algorithms. It relieves the programmer from the task of providing a consistent treatment for every single special case that can occur. The programs that use the technique tend to be considerably smaller and more robust than those that do not use it. We believe that this technique will become a standard tool in writing geometric software."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/15023","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/15023","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/15024","fieldValue":" A detailed description of the implementation of a three-dimensional convex hull algorithm is given. The problems experienced in the production and testing of a correct and robust implementation of a geometric algorithm are discussed. Attention is paid to those issues that are often brushed over in the theoretical descriptions but cause errors in a real computation. These include degeneracies such as coplanar points, floating-point errors, and other special, but not necessarily degenerate, cases."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/15024","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/15024","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/15025","fieldValue":" Background: Direct manipulation interfaces, such as the Macintosh desktop, often represent objects with icons [l, 41. For example, text files are represented by icons. Selection of the icon invokes an editor to view the file it represents, thus the icon not only represents the text file but also represents a text editor used to view the text file. Each type of object is viewed by using a specific program. Diagram objects, for example, require a graphical editor to view. In a typical iconic interface, icons represent a single view of an object.While the single-view single-icon model has proven very intuitive and easy to use, some objects have more than one logical view [2]. Program code can be viewed as text by using a text editor, or it can be viewed as program code by a compiler. The machine code that corresponds to the program code can be thought of as another view, thus the execution of a program can be thought of as another view of program code. This paper describes a mechanism for grouping a set of icons that depict several views of a single object into one multidimensional icon.Multidimensional icons group sets of icons, each describing a unique view of an object, into a single entity. The individual icons are projected onto the sides of a simulated cube. There are two distinct advantages to using a cube instead of displaying all the icons in a menu. The first advantage is that since cubes are very familiar objects, it is a natural mental model to think of the faces of a cube as views of the entire cubeâ\u20AC\u201Dviews of the actual object. The second advantage is that by allowing rotation of the cube, several icons representing views of an object are accessible using only a fraction of the screen space required to display all the icons."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/15025","fieldValue":"ACM"}