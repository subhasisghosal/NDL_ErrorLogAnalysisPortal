{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/13229","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/13229","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/13230","fieldValue":" Coverage is an important measure for the quality and completeness of the functional verification of hardware logic designs. Verification teams spend a significant amount of time looking for bugs in the design and in providing high-quality coverage. This process is performed through the use of various sampling strategies for selecting test inputs. The selection of sampling strategies to achieve the verification goals is typically carried out in an intuitive manner. We studied several commonly used sampling strategies and provide a probabilistic framework for assessing and comparing their relative values. For this analysis, we derived results for two measures of interest: first, the probability of finding a bug within a given number of samplings; and second, the expected number of samplings until a bug is detected. These results are given for both recurring sampling schemes, in which the same inputs might be selected repeatedly, and for nonrecurring sampling schemes, in which already sampled inputs are never selected again. By considering results from the theory of search, and more specifically, from the well-known multiarmed bandit problem, we demonstrate the optimality of a greedy sampling strategy within our defined framework."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/13230","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/13230","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/2261","fieldValue":" Given a sequence S &equals; $s1s2â\u20AC¦s_n of integers smaller than r &equals; O(polylog(n)), we show how S can be represented using nH0(S) &plus; o(n) bits, so that we can know any sq, as well as answer rank and select queries on S, in constant time. H0(S) is the zero-order empirical entropy of S and nH0(S) provides an information-theoretic lower bound to the bit storage of any sequence S via a fixed encoding of its symbols. This extends previous results on binary sequences, and improves previous results on general sequences where those queries are answered in O(log r) time. For larger r, we can still represent S in nH0(S) &plus; o(n log r) bits and answer queries in O(log r\/log log n) time. Another contribution of this article is to show how to combine our compressed representation of integer sequences with a compression boosting technique to design compressed full-text indexes that scale well with the size of the input alphabet Î£. Specifically, we design a variant of the FM-index that indexes a string T[1, n] within nHk(T) &plus; o(n) bits of storage, where Hk(T) is the kth-order empirical entropy of T. This space bound holds simultaneously for all k â\u2030¤ Î± log&verbar;Î£&verbar;$ n, constant 0 < Î± < 1, and &verbar;Î£&verbar; &equals; O(polylog(n)). This index counts the occurrences of an arbitrary pattern P[1, p] as a substring of T in O(p) time; it locates each pattern occurrence in $O(log^1&plus;&epsiv; n) time for any constant 0 < &epsiv; < 1; and reports a text substring of length &ell; in O(&ell; &plus; log1&plus;&epsiv; n) time. Compared to all previous works, our index is the first that removes the alphabet-size dependance from all query times, in particular, counting time is linear in the pattern length. Still, our index uses essentially the same space of the kth-order entropy of the text T, which is the best space obtained in previous work. We can also handle larger alphabets of size &verbar;Î£&verbar; &equals; O(nÎ²$), for any 0 < Î² < 1, by paying o(n log&verbar;Î£&verbar;) extra space and multiplying all query times by O(log &verbar;Î£&verbar;\/log log n)."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/2261","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/2261","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/13231","fieldValue":"Sun, Wei-Tsun"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/13231","fieldValue":" GALS-Designer is a framework for the design of software systems which comply with the formal Globally Asynchronous Locally Synchronous model of computation (GALS). Those systems consist of single or multiple GALS programs and their immediate environment, which can be other programs and any other modules described in SystemC. The framework integrates our libGALS library for writing GALS programs and SystemC. It enables modeling and simulation of single and multiple GALS programs within the single SystemC executable model on the host (simulation) operating system. The same GALS programs can then be run without SystemC on a target operating system for which the libGALS runtime library is available. The use of the GALS-Designer is demonstrated on an example of a complex embedded system. As libGALS can execute on multiprocessor platforms both the simulation and target models of the GALS system can take advantage of multiprocessor and multicore systems, which is not possible when using standard SystemC. Results of running simulation models of GALS programs demonstrate simulation performance improvement when executing on multicore platforms."}