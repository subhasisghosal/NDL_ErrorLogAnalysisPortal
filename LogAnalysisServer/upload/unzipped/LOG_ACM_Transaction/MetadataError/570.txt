{"fieldName":"dc.title","informationCode":"WARN_TEXT_LENGTH_LARGE","handle":"12345678_acm\/12831","fieldValue":"An efficient register optimization algorithm for high-level synthesis from hierarchical behavioral specifications"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/12831","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/12831","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/12832","fieldValue":"Lin, Shi-Zheng Eric"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/12832","fieldValue":"Hsu, Yu-Chin"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/12832","fieldValue":"Tsai, Fur-Shing"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/12832","fieldValue":" An interesting property of a latch-based design is that the combinational path delay is allowed to be longer than the clock cycle as long as it can \"borrow\" time from the shorter paths in the subsequent logic stages. This gives designers a lot of flexibility in designing circuits, especially high performance ones. However, it also increases the complexity in timing analysis. Finding the best clock period or determining how much time to borrow from the subsequent logic stages is difficult especially for designs containing multiple clocks, mixed-clock paths, user-specified multicycle paths, and false paths. In this article, we formulate the time borrowing problem as a linear programming problem. An optimal time borrowing solution can be found by solving the formulation. Based on this time borrowing solver, algorithms are proposed for timing optimization to achieve the optimal clock period. Experimental results show our algorithm is efficient and yields very good results."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/12832","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/12832","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/12833","fieldValue":" A new problem called monotone bipartitioning of a planar point set is identified which is found to be useful in VLSI layout design. Let F denote a rectangular floor containing a set A of n points. The portion of a straight line formed by two points from the set A is called a line segment. A monotone increasing path (MP) in F is a connected and ordered sequence of line segments from the bottom-left corner of F to its top-right corner, such that the slope of each line segment is nonnegative, and each pair of consecutive line segments share a common point of A. An MP is said to be maximal (MMP) if no other point in A can be included in it preserving monotonicity. Let $A^L denote the subset of A corresponding to the end points of the line segments in an MMP, L. The path L partitions the set of points A\\AL into two subsets lying on its two sides. The objective of monotone bipartitioning is to find an MMP L, such that the difference in the number of points in these two subsets is minimum. This problem can be formulated as finding a path between two designated vertices of an edge-weighted digraph (the weight of an edge being an integer lying in the range [-n, n]), for which the absolute value of the algebraic sum of weights is minimized. An O(n√\u2014 e) time algorithm is proposed for this problem, where e denotes the number of edges of the graph determined from the geometry of the point set. The monotone bipartitioning problem has various applications to image processing, facility location, and plant layout problems. A related problem arises while partitioning a VLSI floorplan. Given a floorplan with n rectangular blocks, the goal is to find a monotone staircase channel from one corner of the floor to its diagonally opposite corner such that the difference in the numbers of blocks lying on its two sides is minimum. The problem is referred to as the staircase bipartitioning problem. The proposed algorithm for a point set can be directly used to solve this problem in O(n2$) time. However, an improved O(n) time algorithm is reported for this special case. This leads to an O(n log n) time algorithm for hierarchical decomposition of a floorplan with a sequence of staircase channels. Staircase bipartitioning has many applications to channel and global routing."}