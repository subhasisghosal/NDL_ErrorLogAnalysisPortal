{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/13285","fieldValue":" This article presents a joint framework for quantization and Multiple Constant Multiplication (MCM) optimization, which yields a computationally efficient implementation of multiplierless multiplication in hardware and software. Frameworks of this nature have been developed in the context of Finite Impulse Response (FIR) filters, where frequency response specifications are used to drive the design. In this work, we look at a general case, considering as given a vector of ideal, real constants, which may come from any application and do not necessarily represent FIR filter coefficients. We first formulate a joint optimization problem for finding a fixed-point vector and a shift-add network that are optimal in terms of quantization error and MCM complexity. We then describe ways to finitize and prune the search space, leading to an efficient algorithm called JOINT_SOLVE that solves the problem. Finally, via extensive randomized experiments, we show that our joint framework is notably more computationally efficient than a disjointed one, reducing the MCM cost by 15&percnt;--60&percnt; on moderate size problems."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/13285","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/13285","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/13286","fieldValue":" Satisfying the timing constraint is the utmost concern in the integrated circuit design and it is true that most critical timing paths in a circuit cover one or more arithmetic components such as adder, subtractor, and multiplier of which addition logic is commonly involved. This work addresses the problem of redesigning the addition logic (in a form of hybrid adder) on a critical timing path to meet the timing constraint while minimally allocating the required addition logic. Unlike the conventional hybrid adder design schemes in which they assume uniform or specific patterns of input signal arrival times and minimize the latest timing of the output signals, our work extracts the required timing of each output signal as well as the input arrival times directly from the circuit and resynthesizes the addition logic by creating a customized hybrid adder that is best suited, in terms of logic area, for meeting the timing constraint of the circuit. Specifically, we propose a systematic approach of hybrid adder design exploration, basically following the principle of dynamic programming with well-controlled pruning techniques. This work is realistic and practically very useful in that it can be used as a timing optimizer to the computation-intensive circuits with a tight timing budget. We provide a set of diverse experimental data to show how much the proposed hybrid adder scheme is effective in meeting or reducing timing while maintaining the circuit area as minimal as possible."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/13286","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/13286","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/2266","fieldValue":" In this article, we present a new data structure, called the permutation tree, to improve the running time of sorting permutation by transpositions and sorting permutation by block interchanges. The existing 1.5-approximation algorithm for sorting permutation by transpositions has time complexity $O(n^3\/2 &sqrt;logn). By means of the permutation tree, we can improve this algorithm to achieve time complexity O(nlogn). We can also improve the algorithm for sorting permutation by block interchanges to take its time complexity from O(n2$) down to O(nlogn)."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/2266","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/2266","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/13287","fieldValue":"Backes, John D"}