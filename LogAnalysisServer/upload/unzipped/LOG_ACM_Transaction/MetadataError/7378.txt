{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/9566","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/9566","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/1863","fieldValue":" Dynamic or Just-in-Time (JIT) compilation is essential to achieve high-performance emulation for programs written in managed languages, such as Java and C&num;. It has been observed that a conservative JIT compilation policy is most effective to obtain good runtime performance without impeding application progress on single-core machines. At the same time, it is often suggested that a more aggressive dynamic compilation strategy may perform best on modern machines that provide abundant computing resources, especially with virtual machines (VMs) that are also capable of spawning multiple concurrent compiler threads. However, comprehensive research on the best JIT compilation policy for such modern processors and VMs is currently lacking. The goal of this work is to explore the properties of single-tier and multitier JIT compilation policies that can enable existing and future VMs to realize the best program performance on modern machines. In this work, we design novel experiments and implement new VM configurations to effectively control the compiler aggressiveness and optimization levels (if and when methods are compiled) in the industry-standard Oracle HotSpot Java VM to achieve this goal. We find that the best JIT compilation policy is determined by the nature of the application and the speed and effectiveness of the dynamic compilers. We extend earlier results showing the suitability of conservative JIT compilation on single-core machines for VMs with multiple concurrent compiler threads. We show that employing the free compilation resources (compiler threads and hardware cores) to aggressively compile more program methods quickly reaches a point of diminishing returns. At the same time, we also find that using the free resources to reduce compiler queue backup (compile selected hot methods early) significantly benefits program performance, especially for slower (highly optimizing) JIT compilers. For such compilers, we observe that accurately prioritizing JIT method compiles is crucial to realize the most performance benefit with the smallest hardware budget. Finally, we show that a tiered compilation policy, although complex to implement, greatly alleviates the impact of more and early JIT compilation of programs on modern machines."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/1863","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/1863","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/9567","fieldValue":" With the advent of next-generation, bandwidth-intensive multimedia applications such as HDTV, interactive distance learning, and movie broadcasts from studios, it is becoming imperative to exploit the enormous bandwidth promised by the rapidly growing wavelength-division-multiplexing (WDM) technology. These applications require multicasting of information from a source to several destination nodes which should be performed judiciously to conserve expensive network resources. In this study, we investigate two switch architectures to support multicasting in a WDM network: one using an opaque (optical-electronic-optical approach and the other using a transparent (all-optical) approach. For both these switch architectures, we present mathematical formulations for routing and wavelength assignment of several light-tree-based multicast sessions on a given network topology at a globally optimal cost. We expand our work to also accommodate: 1) fractional-capacity sessions (where a session's capacity is a fraction of a wavelength channel's bandwidth, thereby leading to \"traffic-groomed\" multicast sessions) and 2) sparse splitting constraints, i.e., limited fanout of optical splitters and limited number of such splitters at each node. We illustrate the solutions obtained on different networks by solving these optimization problems, which turn out to be mixed integer linear programs (MILPs). Because the MILP is computationally intensive and does not scale well for large problem sizes, we also propose fast heuristics for establishing a set of multicast sessions in a network with or without wavelength converters and with fractional-capacity sessions. We find that, for all scenarios, the heuristics which arrange the sessions in ascending order with respect to destination set size and\/or cost perform better in terms of network resource usage than the heuristics which arrange the sessions in descending order."}{"fieldName":"dc.identifier.other","informationCode":"ERR_NULL_VALUE","handle":"12345678_acm\/9567","fieldValue":"{\"eissn\":\"\"}"}{"fieldName":"dc.title","informationCode":"WARN_TEXT_LENGTH_LARGE","handle":"12345678_acm\/9567","fieldValue":"Optimal multicasting of multiple light-trees of different bandwidth granularities in a WDM mesh network with sparse splitting capabilities"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/9567","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/9567","fieldValue":"ACM"}