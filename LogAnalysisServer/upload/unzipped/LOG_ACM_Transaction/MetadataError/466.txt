{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/12474","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/12475","fieldValue":" Let f : {0, 1}n â\u2020\u2019 {0, 1}. Let Î¼ be a product probability measure on {0, 1}n. For &epsi; â\u2030¥ 0, we define D&epsi;(f), the &epsi;-approximate decision tree complexity of f, to be the minimum depth of a decision tree T with Î¼(T(x) â\u2030  f(x)) â\u2030¤ &epsi;. For j = 0 or 1 and for Î\u201D â\u2030¥ 0, we define Cj,Î\u201D(f), the Î\u201D-approximate j-certificate complexity of f, to be the minimum certificate complexity of a set A âŠ\u2020 Î© with $Î¼(AÎ\u201Df^âˆ\u20191$(j)) â\u2030¤ &epsi;. Note that if Î¼(x) > 0 for all x then $D_0(f) = D(f) and Cj,0(f) = Cj(f) are the ordinary decision tree and j-certificate complexities of f, respectively. We extend the well-known result, D(f) â\u2030¤ C1(f)C0(f) [Blum and Impagliazzo 1987; Hartmanis and Hemachandra 1991; Tardos 1989], proving that for all &epsi; > 0 there exists a Î\u201D > 0 and a constant K = K(&epsi;, Î\u201D) > 0 such that for all n, Î¼, f, D&epsi;(f) â\u2030¤ K C1,Î\u201D(f)C0,$Î\u201D (f). We also give a partial answer to a related question on query complexity raised by Tardos [1989]. We prove generalizations of these results to general product probability spaces."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/12475","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/12475","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/12476","fieldValue":"McKenzie, Pierre"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/12476","fieldValue":" We introduce the tree evaluation problem, show that it is in LogDCFL (and hence in P), and study its branching program complexity in the hope of eventually proving a superlogarithmic space lower bound. The input to the problem is a rooted, balanced d-ary tree of height h, whose internal nodes are labeled with d-ary functions on [k]â\u20AC\u2030=â\u20AC\u2030{1,..., k}, and whose leaves are labeled with elements of [k]. Each node obtains a value in [k] equal to its d-ary function applied to the values of its d children. The output is the value of the root. We show that the standard black pebbling algorithm applied to the binary tree of height h yields a deterministic k-way branching program with $O(k^h) states solving this problem, and we prove that this upper bound is tight for hâ\u20AC\u2030=â\u20AC\u20302 and hâ\u20AC\u2030=â\u20AC\u20303. We introduce a simple semantic restriction called thrifty on k-way branching programs solving tree evaluation problems and show that the same state bound of Î˜(kh) is tight for all hâ\u20AC\u2030â\u2030¥â\u20AC\u20302 for deterministic thrifty programs. We introduce fractional pebbling for trees and show that this yields nondeterministic thrifty programs with Î˜(kh\/2+1$) states solving the Boolean problem â\u20ACœdetermine whether the root has value 1â\u20AC?, and prove that this bound is tight for hâ\u20AC\u2030=â\u20AC\u20302,3,4. We also prove that this same bound is tight for unrestricted nondeterministic k-way branching programs solving the Boolean problem for hâ\u20AC\u2030=â\u20AC\u20302,3."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/12476","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/12476","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/12477","fieldValue":" Locally decodable codes are error-correcting codes with the extra property that, in order to retrieve the value of a single input position, it is sufficient to read a small number of positions of the codeword. We refer to the probability of getting the correct value as the correctness of the decoding algorithm. A breakthrough result by Yekhanin [2007] showed that 3-query linear locally decodable codes may have subexponential length. The construction of Yekhanin, and the three query constructions that followed, achieve correctness only up to a certain limit which is 1â\u20AC\u2030âˆ\u2019â\u20AC\u20303Î\u201D for nonbinary codes, where an adversary is allowed to corrupt up to Î\u201D fraction of the codeword. The largest correctness for a subexponential length 3-query binary code is achieved in a construction by Woodruff [2008], and it is below 1â\u20AC\u2030âˆ\u2019â\u20AC\u20303Î\u201D. We show that achieving slightly larger correctness (as a function of Î\u201D) requires exponential codeword length for 3-query codes. Previously, there were no larger than quadratic lower bounds known for locally decodable codes with more than 2 queries, even in the case of 3-query linear codes. Our lower bounds hold for linear codes over arbitrary finite fields and for binary nonlinear codes. Considering larger number of queries, we obtain lower bounds for q-query codes for qâ\u20AC\u2030>â\u20AC\u20303, under certain assumptions on the decoding algorithm that have been commonly used in previous constructions. We also prove bounds on the largest correctness achievable by these decoding algorithms, regardless of the length of the code. Our results explain the limitations on correctness in previous constructions using such decoding algorithms. In addition, our results imply trade-offs on the parameters of error-correcting data structures."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/12477","fieldValue":"ACM"}