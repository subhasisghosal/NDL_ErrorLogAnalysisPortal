{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/2262","fieldValue":" Let T be a string with n characters over an alphabet of constant size. A recent breakthrough on compressed indexing allows us to build an index for T in optimal space (i.e., O(n) bits), while supporting very efficient pattern matching [Ferragina and Manzini 2000; Grossi and Vitter 2000]. Yet the compressed nature of such indexes also makes them difficult to update dynamically. This article extends the work on optimal-space indexing to a dynamic collection of texts. Our first result is a compressed solution to the library management problem, where we show an index of O(n) bits for a text collection L of total length n, which can be updated in O(&verbar;T&verbar; log n) time when a text T is inserted or deleted from L; also, the index supports searching the occurrences of any pattern P in all texts in L in O(&verbar;P&verbar; log n &plus; occ $log^2 n) time, where occ is the number of occurrences. Our second result is a compressed solution to the dictionary matching problem, where we show an index of O(d) bits for a pattern collection D of total length d, which can be updated in O(&verbar;P&verbar; log2 d) time when a pattern P is inserted or deleted from D; also, the index supports searching the occurrences of all patterns of D in any text T in O((&verbar;T&verbar; &plus; occ)log2 d) time. When compared with the O(d log d)-bit suffix-tree-based solution of Amir et al. [1995], the compact solution increases the query time by roughly a factor of log d only. The solution to the dictionary matching problem is based on a new compressed representation of a suffix tree. Precisely, we give an O(n)-bit representation of a suffix tree for a dynamic collection of texts whose total length is n, which supports insertion and deletion of a text T in O(&verbar;T&verbar; log2$ n) time, as well as all suffix tree traversal operations, including forward and backward suffix links. This work can be regarded as a generalization of the compressed representation of static texts. In the study of the aforementioned result, we also derive the first O(n)-bit representation for maintaining n pairs of balanced parentheses in O(log n\/log log n) time per operation, matching the time complexity of the previous O(n log n)-bit solution."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/2262","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/2262","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/13241","fieldValue":" A clock polarity assignment method is proposed that reduces the peak current on the vdd\/gnd rails of an integrated circuit. The impacts of (i) the output capacitive load on the peak current drawn by the sink-level clock buffers, and (ii) the buffer\/inverter replacement scheme of polarity assignment on timing accuracy are considered in the formulation. The proposed sink-level-only polarity assignment is performed by a lexi-search algorithm in order to balance the peak current on the clock tree. Most of the previous polarity assignment methods that do not include clock tree resynthesis lead to an undesirable increase in the worst corner clock skew. Hence, a skew-tuning scheme is proposed that reduces the clock skew through polarity refinement and not through clock tree resynthesis. The proposed polarity assignment method with the skew-tuning scheme is implemented within an industrial design flow for practicality. Experimental results show that the worst-case peak current drawn by the clock tree can be reduced by an average of 36.5&percnt;. The worst corner clock skew is increased from 60.7ps to 76.2ps by applying the proposed polarity assignment method. The proposed skew-tuning scheme reduces the worst-case clock skew from 76.2ps to 61.5ps, on average, with a limited degradation in the peak current improvement (36.5&percnt; to 31.2&percnt;, on average)."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/13241","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/13241","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/13242","fieldValue":"Yeh, Arthur B"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/13242","fieldValue":" To satisfy the requirements of complex and special analog layout constraints, a new analog layout retargeting method is presented in this article. Our approach uses geometric programming (GP) to achieve new technology design rules, implement device symmetry and matching constraints, and manage parasitics optimization. The GP, a class of nonlinear optimization problem, can be transferred or fitted into a convex optimization problem. Therefore, a global optimum solution can be achieved. Moreover, the GP can address problems with large-scale variables and constraints without setting an initialization variable range. To meet the prerequisites of the GP methodology for analog layout automation, we propose three kinds of mathematical transformations, including negative coefficient transformation, fraction transformation, and maximum of posynomial transformation. The efficiency and effectiveness of the proposed algorithm, as compared with the other existing methods, are demonstrated by a basic case-study example: a two-stage Miller-compensated operational amplifier and a single-ended folded cascode operational amplifier."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/13242","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/13242","fieldValue":"ACM"}