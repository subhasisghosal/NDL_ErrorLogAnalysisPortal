{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18863","fieldValue":" Interval arithmetic is useful in automatically verified computations, that is, in computations in which the algorithm itself rigorously proves that the answer must lie within certain bounds. In addition to rigor, interval arithmetic also provides a simple and sometimes sharp method of bounding ranges of functions for global optimization and other tasks. Convenient use of interval arithmetic requires an interval data type in the programming language. Although various packages supply such a data type, previous ones are machine specific, obsolete, and unsupported, for languages other than Fortran, or commercial. The Fortran 90 module INTERVAL_ARITHMETIC provides a portable interval data type in Fortran 90. This data type is based on two double-precision real Fortran storage units. Module INTERVAL_ARTHMETIC uses the Fortran 77 library INTLIB (ACM TOMS Algorithm 737) as a supporting library. The module has been employed extensively in the author's own research."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18863","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18863","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18864","fieldValue":" The construction of elementary unitary matrices that transform a complex vector to a multiple of e1, the first column of the identity matrix, is studied. We present four variants and their software implementation, including a discussion onthe LAPACK subroutine CLARFG. Comparisons are also given."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18864","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18864","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18865","fieldValue":" Recently, the so-called DESI (diagonally extended singly implicit) Runge-Kutta methods were introduced to overcome some of the limitations of singly implicit methods. Preliminary experiments have shown that these methods are usually more efficient than the standard singly implicit Runge-Kutta (SIRK) methods and, in many cases, are competitive with backward differentiation formulae (BDF). This article presents an algorithm for determining the full coefficient matrix from the stability function, which is already chosen to make the method A-stable. Because of their unconventional nature, DESI methods have to be implemented in a special way. In particular, the effectiveness of these methods depends heavily on how starting values are chosen for the stage iterations. These and other implementation questions are descussed in detail, and design choices we have made form the basis of an experimental coe for the solution of stiff problems by DESI methods. We present here a small subset of the numerical results obtained with our code. Many of these results are quite satisfactory and suggest that DESI methods have a useful role in the solution of this type of problem."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18865","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18865","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/18866","fieldValue":"Eastham, Michael S P"}