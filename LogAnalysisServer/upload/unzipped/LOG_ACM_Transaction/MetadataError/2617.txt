{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18797","fieldValue":" This paper describes a Fortran 90 implementation of ACM Transactions on Mathematical Software Algorithm 630, a minimization algorithm designed for use in a limited-memory environment. It includes implementation of the Buckley-LeNir method, Nocedal's limited memory algorithm, and an experimental limited-memory implementation of a factored update due to Powell, as well as a fairly standard quasi-Newton implementation due originally to Shanno. This algorithm uses a number of the new features of Fortran 90 to offer capabilities that were not formerly available."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18797","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18797","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18798","fieldValue":" This article develops an affine-scaling method for linear programming in standard primal form. Its descent search directions are formulated in terms of the null-space of the linear programming matrix, which, in turn, is defined by a suitable basis matrix. We describe some basic properties of the method and an experimental implementation that employs a periodic basis change strategy in conjunction with inexact computation of the search direction by an iterative method, specifically, the conjugate-gradient method with diagonal preconditioning. The result of a numerical study on a number of nontrivial problems representative of problems that arise in practice are reported and discussed.A key advantage of the primal null-space affine-scaling method is its compatibility with the primal simplex method. This is considered in the concluding section, along with implications for the development of a more practical implementation."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18798","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18798","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18799","fieldValue":" Algorithm 708 (BRATIO) was run on 2730 test cases. Comparison of these results with the results from an algorithm using a continued fraction of Tretter and Walster were performed using a high-precision version of the latter algorithm implemented in Maple. Accuracy of BRATIO ranged from 9.64 significant digits to a full machine double-precision, 15.65 significant digits, with the lower value occurring when a was nearly equal to b, and a was large."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18799","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18799","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/18800","fieldValue":"McGill, Kevin C."}