{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/6595","fieldValue":" The instruction cache is a popular optimization target due to the cache's high impact on system performance and power and because of the cache's predictable temporal and spatial locality. This article is an in depth study on the interaction of code reordering (a long-known technique) and cache configuration (a relatively new technique). Experimental results show that code reordering coupled with cache configuration reveals additional energy savings as high as 10--15&percnt; for several benchmarks with reduced cache area as high as 48&percnt;. To exploit these additional benefits, we architect and evaluate several design exploration heuristics for combining these two methods."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/6595","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6595","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/6596","fieldValue":" Important challenges for embedded systems can be addressed by dynamic binary translation. A dynamic binary translator stores translated instructions in a software-managed code cache, which is usually large to minimize overhead. This article shows how to use a small scratchpad memory for the code cache. A small code cache may require frequent code evictions and retranslation, which degrade performance. We propose techniques to reduce the number of instructions inserted by the translator and a way to form fragments that minimizes translated code size. With our techniques, a much smaller code cache can hold a program's translated code working set."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/6596","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6596","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/6597","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6597","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/6598","fieldValue":" In this article, an algorithm is proposed to design liveness-enforcing supervisors for systems of simple sequential processes with resources $(S^3$PR) based on complementary places. Firstly, a mixed integer programming (MIP) based deadlock detection method is used to find unmarked strict minimal siphons from an infinite-capacity net. Next, the finite-capacity net, in which liveness can be enforced, is obtained by adding capacity function to the infinite-capacity net. Finally, complementary-place transformation is used to transform the finite-capacity net into an infinite-capacity net. This article focuses on adding a complementary place to each operation place that is related to unmarked siphons, deals with the deadlock problem from a new view point, and hence advances the deadlock control theory. Compared with the existing methods, the new policy is easier to implement for real industrial systems. More importantly, design of a complementary-place supervisor is very easy. Finally, in some cases, the new policy can obtain a structurally simpler supervisor with more permissive behavior than the existing methods do. A flexible manufacturing systems (FMS) example is used to compare the proposed policy with some other methods."}{"fieldName":"dc.subject","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6598","fieldValue":"FMS"}