{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/22951","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/22951","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/3241","fieldValue":"Shinn-Cunningham, Barbara G."}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/3241","fieldValue":"Gyss, Jean-Franois"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/3241","fieldValue":" Often, virtual acoustic environments present cues that are inconsistent with an individual's normal experiences. Through training, however, an individual can at least partially adapt to such inconsistent cues through either short- [Kassem 1998; Shinn-Cunningham 2000; Shinn-Cunningham et al. 1998a, 1998b; Zahorik 2001] or long- [Hofman et al. 1998] term exposure. The type and degree of inconsistency as well as the length of training determine the final accuracy and consistency with which the subject can localize sounds [Shinn-Cunningham 2000]. The current experiments of short-term adaptation measure how localization bias (mean error) and resolution (precision) change when subjects are exposed to auditory cue rearrangements simpler than those previously investigated. These results, combined with those of earlier experiments, suggest that there is plasticity at many different levels of the spatial auditory processing pathway with different time scales governing the plasticity at different levels of the system. This view of spatial auditory plasticity has important implications for the design of spatial auditory displays."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/3241","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/3241","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/22952","fieldValue":" Call graphs have many applications in software engineering. For example, they serve as the basis for code navigation features in integrated development environments and are at the foundation of static analyses performed in verification tools. While many call graph construction algorithms have been presented in the literature, we are not aware of any that handle Scala features such as traits and abstract type members. Applying existing algorithms to the JVM bytecodes generated by the Scala compiler produces very imprecise results because type information is lost during compilation. We adapt existing type-based call graph construction algorithms to Scala and present a formalization based on Featherweight Scala. An experimental evaluation shows that our most precise algorithm generates call graphs with 1.1--3.7 times fewer nodes and 1.5--17.3 times fewer edges than a bytecode-based RTA analysis."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/22952","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/22952","fieldValue":"ACM"}