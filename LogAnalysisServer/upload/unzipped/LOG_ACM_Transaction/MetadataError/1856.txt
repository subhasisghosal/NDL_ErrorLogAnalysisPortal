{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/16481","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/16481","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/2562","fieldValue":" We give approximation algorithms for the Survivable Network problem. The input consists of a graph G = (V,E) with edge\/node-costs, a node subset S âŠ\u2020 V, and connectivity requirements {r(s,t):s,t âˆˆ T âŠ\u2020 V}. The goal is to find a minimum cost subgraph H of G that for all s,t âˆˆ T contains r(s,t) pairwise edge-disjoint st-paths such that no two of them have a node in S &setmn; {s,t} in common. Three extensively studied particular cases are: Edge-Connectivity Survivable Network (S = âˆ\u2026), Node-Connectivity Survivable Network (S = V), and Element-Connectivity Survivable Network (r(s,t) = 0 whenever s âˆˆ S or t âˆˆ S). Let k = $max_s,t âˆˆ T$ r(s,t). In Rooted Survivable Network, there is s âˆˆ T such that r(u,t) = 0 for all u â\u2030  s, and in the Subset k-Connected Subgraph problem r(s,t) = k for all s,t âˆˆ T. For edge-costs, our ratios are O(k log k) for Rooted Survivable Network and $O(k^2 log k) for Subset k-Connected Subgraph. This improves the previous ratio O(k2 log n), and for constant values of k settles the approximability of these problems to a constant. For node-costs, our ratios are as follows. â\u20AC\u201DO(k log |T|) for Element-Connectivity Survivable Network, matching the best known ratio for Edge-Connectivity Survivable Network. â\u20AC\u201DO(k2 log |T|) for Rooted Survivable Network and O(k3 log |T|) for Subset k-Connected Subgraph, improving the ratio O(k8 log2 |T|). â\u20AC\u201DO(k4 log2$ |T|) for Survivable Network; this is the first nontrivial approximation algorithm for the node-costs version of the problem."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/2562","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/2562","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/16482","fieldValue":" We propose a practical method for synthesizing plausible fire sounds that are synchronized with physically based fire animations. To enable synthesis of combustion sounds without incurring the cost of time-stepping fluid simulations at audio rates, we decompose our synthesis procedure into two components. First, a low-frequency flame sound is synthesized using a physically based combustion sound model driven with data from a visual flame simulation run at a relatively low temporal sampling rate. Second, we propose two bandwidth extension methods for synthesizing additional high-frequency flame sound content: (1) spectral bandwidth extension which synthesizes higher-frequency noise matching combustion sound spectra from theory and experiment; and (2) data-driven texture synthesis to synthesize high-frequency content based on input flame sound recordings. Various examples and comparisons are presented demonstrating plausible flame sounds, from small candle flames to large flame jets."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/16482","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/16482","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/16483","fieldValue":" Although there is an abundance of 3D models available, most of them exist only in virtual simulation and are not immediately usable as physical objects in the real world. We solve the problem of taking as input a 3D model of a man-made object, and automatically generating the parts and connectors needed to build the corresponding physical object. We focus on furniture models, and we define formal grammars for IKEA cabinets and tables. We perform lexical analysis to identify the primitive parts of the 3D model. Structural analysis then gives structural information to these parts, and generates the connectors (i.e. nails, screws) needed to attach the parts together. We demonstrate our approach with arbitrary 3D models of cabinets and tables available online."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/16483","fieldValue":"ACM"}