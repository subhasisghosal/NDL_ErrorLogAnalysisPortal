{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18996","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18997","fieldValue":" We use inequalities to design short universal algorithms that can be used to generate random variates from large classes of univariate continuous or discrete distributions (including all log-concave distributions). The expected time is uniformly bounded over all these distributions. The algorithms can be implemented in a few lines of high-level language code. In opposition to other black-box algorithms hardly any setup step is required, and thus it is superior in the changing-parameter case."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18997","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18997","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18998","fieldValue":" PREQN is a package of Fortran 77 subroutins for automatically generating preconditioners for the conjugate gradient method. It is designed for solving a sequence of linear systems Aix = bi, i = 1â\u20AC¦, t, where the coefficient matrices Ai are symmetric and positive definite and vary slowly. Problems of this type arise, for example, in nonlinear optimization. The preconditioners are based on limited-memory quasi-Newton updating and are recommended for problems in which (i) the coefficient matrices are not explicitly known and only matrix-vector products of the form Aiv can be computed; or (ii) the coefficient matrices are not sparse. PREQN is written so that a single call from a conjugate gradient routine performs the preconditioning operation and stores information needed for the generation of a new preconditioner."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18998","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18998","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18999","fieldValue":" This paper introduces a precision- and range-independent tool for testing the compliance of hardware or software implementations of (multiprecision) floating-point arithmetic with the principles of the IEEE standards 754 and 854. The tool consists of a driver program, offering many options to test only specific aspects of the IEEE standards, and a large set of test vectors, encoded in a precision-independent syntax to allow the testing of basic and extended hardware formats as well as multiprecision floating-point implementations. The suite of test vectors stems on one hand from the integration and fully precision- and range-independent generalization of existing hardware test sets, and on the other hand from the systematic testing of exact rounding for all combinations of round and sticky bits that can occur. The former constitutes only 50% of the resulting test set. In the latter we especially focus on hard-to-round cases. In addition, the test suite implicitly tests properties of floating-point operations, following the idea of Paranoia, and it reports which of the three IEEE-compliant underflow mechanisms is used by the floating-point implementation under consideration. We also chech whether that underflow mechanism is used consistently. The tool is backward compatible with the UCBTEST package and with Coonen's test syntax."}{"fieldName":"dc.title","informationCode":"WARN_TEXT_LENGTH_LARGE","handle":"12345678_acm\/18999","fieldValue":"A precision- and range-independent tool for testing floating-point arithmetric I: basic operations, square root, and remainder"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18999","fieldValue":"ACM"}