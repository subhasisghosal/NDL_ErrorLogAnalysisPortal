{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/15139","fieldValue":"Bar-Yehuda, Reuven"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/15139","fieldValue":" We investigate architechural schemes, generalizing that of existing graphics engines, supporting fast rendering of traingle meshes. A mesh defined on n vertices is rendered by sending vertices down a graphics pipeline, after which they are pushed on a stack to by popped when no longer needed. Only individual traingles whose vertices are present in the stack may be rendered. The storage cost of the mesh rendering is the size of the stack required to store mesh vertices during the rendering process. This may be significantly less than n. The time cost of the mesh rendering is the number of vertices sent down the graphics pipeline. If a large enough stack is available, it usuffices to send each vertix once. If only a small stack is available, some vertices may have to be sent more than once, so a time\/space tradeoff exists. With our architecture, stack of size O n is sufficient to render any triangle mesh defined on n vertices, such that each vertex is sent only once through the graphics pipeline (time cost = n). We provide an algorithm that generates an appropriate â\u20ACœrendering sequenceâ\u20AC? of commands for any given mesh. Moreover, we show that no algorithm can do better, that is, Wn is a lower bound. Some n-vertex meshes may be rendered using a stack whose size is significantly less than On. An algorithm generating a minimum-time rendering sequence rquiring the minimum stack size is an open question. We provide an approximation: if it is theoretically possible to render a triangle mesh is minimum time with a stack of size S, our algoithm generates a minimum-time rendering sequence requiring a stack of size no larger than 2S log3\/2n. If only a stack of size k is available, we provide an algorithm generating a rendering sequence requiring a stack of size no larger than k, such that at most n(1+c\/k) vertices must be sent through the pipeline, for some constant c."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/15139","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/15139","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/15140","fieldValue":" Three methods for evaluating the surface coordinates, first derivatives, and normal vectors of a NURB surface are compared. These methods include forward differencing, knot insertion, and a tow-stage Cox-de Boor technique. The computational complexity of each of these techniques is analyzed and summarized. The use of Hermite functions is shown to yield a poor approximation for the shading functions of a NURB surface. An improved method for computing derivatives by knot insertion is presented. An efficient algorithm for computing the foward difference matrix and a method for using foward differencing to compute the first derivatives of a NURB surface are also presented."}{"fieldName":"dc.subject","informationCode":"ERR_FOUND_HTML_TAG","handle":"12345678_acm\/15140","fieldValue":"<italic>B<\/italic>-spline"}{"fieldName":"dc.subject","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/15140","fieldValue":"NURBS"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/15140","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/15140","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/15141","fieldValue":" We present a new clustering algorithm for global illumination in complex environments. The new algorithm extends provious work on clustering for radiosity to allow for nondiffuse (glossy) reflectors. We represent clusters as points with directional distributions of outgoing and incoming radiance and importance, and we derive an error bound for transfers between these clusters. The algorithm groups input surfaces into a hierarchy of clusters, and then permits clusters to interact only if the error bound is below an acceptable tolerance. We show that the algorithm is asymptotically more efficient than previous clustering algorithms even when restricted to ideally diffuse environments. Finally, we demonstrate the performance of our method on two complex glossy environments."}