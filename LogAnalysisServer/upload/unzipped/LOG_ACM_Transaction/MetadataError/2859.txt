{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/19375","fieldValue":" A MATLAB toolbox, IIPBF, for calculating infinite integrals involving a product of two Bessel functions $Ja(Ï?x)J_b(Ï\u201E x), Ja(Ï? x)Yb(Ï\u201E x) and Ya(Ï?x)Yb(Ï\u201E x), for non-negative integers a,b, and a well-behaved function f(x), is described. Based on the Lucas algorithm previously developed for Ja(Ï? x)Jb(Ï\u201E x) only, IIPBF recasts each product as the sum of two functions whose oscillatory behavior is exploited in the three-step procedure of adaptive integration, summation, and extrapolation. The toolbox uses customised QUADPACK and IMSL functions from a MATLAB conversion of the SLATEC library. In addition, MATLAB's own quadgk function for adaptive Gauss-Kronrod quadrature results in a significant speed up compared with the original algorithm. Usage of IIPBF is described and eighteen test cases illustrate the robustness of the toolbox; five additional ones are used to compare IIPBF with the BESSELINT code for rational and exponential forms of f(x) with Ja(Ï?x)Jb$(Ï\u201E x). Reliability for a broad range of values of Ï? and Ï\u201E for the three different product types as well as different orders in one case is demonstrated. An electronic appendix provides a novel derivation of formulae for five cases."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/19375","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/19375","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/19376","fieldValue":" A code is presented which offers a simple clean way to get output that is very easy to read. Special support is given for the output of error messages which are a part of an application package or subprogram library. The code uses many of the features in Fortran 2003, and the â\u20ACœNEWUNIT=â\u20AC? in an open statement from Fortran 2008. The latter can easily be replaced with â\u20ACœUNIT=99â\u20AC?. One goal here is to illustrate some of the nice features in recent incarnations of Fortran."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/19376","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/19376","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/19377","fieldValue":"Choi, Sou-Cheng T"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/19377","fieldValue":"Saunders, Michael A"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/19377","fieldValue":" We describe algorithm MINRES-QLP and its FORTRAN 90 implementation for solving symmetric or Hermitian linear systems or least-squares problems. If the system is singular, MINRES-QLP computes the unique minimum-length solution (also known as the pseudoinverse solution), which generally eludes MINRES. In all cases, it overcomes a potential instability in the original MINRES algorithm. A positive-definite preconditioner may be supplied. Our FORTRAN 90 implementation illustrates a design pattern that allows users to make problem data known to the solver but hidden and secure from other program units. In particular, we circumvent the need for reverse communication. Example test programs input and solve real or complex problems specified in Matrix Market format. While we focus here on a FORTRAN 90 implementation, we also provide and maintain MATLAB versions of MINRES and MINRES-QLP."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/19377","fieldValue":"ACM"}