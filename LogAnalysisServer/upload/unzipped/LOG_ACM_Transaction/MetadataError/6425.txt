{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/7074","fieldValue":" This article presents Clover, a compiler-directed soft error detection and recovery scheme for lightweight soft error resilience. The compiler carefully generates soft-error-tolerant code based on idempotent processing without explicit checkpoints. During program execution, Clover relies on a small number of acoustic wave detectors deployed in the processor to identify soft errors by sensing the wave made by a particle strike. To cope with DUEs (detected unrecoverable errors) caused by the sensing latency of error detection, Clover leverages a novel selective instruction duplication technique called tail-DMR (dual modular redundancy) that provides a region-level error containment. Once a soft error is detected by either the sensors or the tail-DMR, Clover takes care of the error as in the case of exception handling. To recover from the error, Clover simply redirects program control to the beginning of the code region where the error is detected. The experimental results demonstrate that the average runtime overhead is only 26%, which is a 75% reduction compared to that of the state-of-the-art soft error resilience technique. In addition, this article evaluates an alternative technique called tail-wait, comparing it to Clover. According to the evaluation with the different processor configurations and the various error detection latencies, Clover turns out to be a superior technique, achieving 1.06 to 3.49 Ã\u2014 speedup over the tail-wait."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/7074","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/7074","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/7075","fieldValue":"Chang, Li-Pin"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/7075","fieldValue":"Sung, Po-Han"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/7075","fieldValue":"Chen, Po-Tsang"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/7075","fieldValue":"Chen, Po-Hung"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/7075","fieldValue":" Flash storage has been a standard component in Android devices. Recent research has reported that application data management in Android involves frequent fsync() operations. The current fsync() implementations, including those of ext4 and F2FS, have several common drawbacks. Specifically, ext4 commits a transaction every time to sync a file, whereas F2FS commits a checkpoint to sync a directory. Committing a transaction or checkpoint flushes all dirty data from the page cache to the flash storage via many small, random block write requests. The resultant high I\/O frequency and excessive write traffic cause a high fsync() latency. This study presents an efficient fsync() method, called eager synching, which is based on a simple idea: write less, and write sequentially. To sync a file, eager synching writes only a subset of all dirty data in the page cache to a sequential log space using a few sequential block write requests. It does not involve transaction or checkpoint committing. We successfully implemented eager synching in ext4 and F2FS, and our experimental results show that, compared with the original fsync() methods of ext4 and F2FS, eager synching reduced the average and maximum fsync() latencies by up to 72% and 91%, respectively, block-level write traffic by up to 35%, and I\/O frequency by up to 66%. Through enhanced crash recovery procedures, eager synching can successfully recover all previously synched files while still guaranteeing the file system integrity. We also conducted live application replays using the proposed eager synching approach and observed that this approach significantly improved the application frame updating rate and application execution time."}{"fieldName":"dc.subject","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/7075","fieldValue":"EMMC"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/7075","fieldValue":"ACM"}