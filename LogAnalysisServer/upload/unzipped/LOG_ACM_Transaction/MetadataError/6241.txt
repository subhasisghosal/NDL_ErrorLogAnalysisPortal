{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/6633","fieldValue":" Launch delay has been an important factor affecting users' experiences in mobile multimedia applications. To launch applications quickly, modern mobile systems such as Android usually keep inactive applications in the background and manage them through an LRU-based activity stack. Whenever the user wants to run and interact with a background application again, that application can be switched back into the foreground quickly from the activity stack without delay in initializing the applications anew. Since background multimedia applications often continuously consume the battery power of the smart phone, the challenge is to effect a balance between application launch delay and battery lifetime. In this article, we propose innovative application management strategies that terminate â\u20ACœunbeneficialâ\u20AC? background applications to save energy and pre-launch â\u20ACœbeneficialâ\u20AC? applications to improve the application launch delay. The proposed strategies are evaluated through a trace-driven simulation and a real experiment. The results show that the average application launch delay can be reduced by 15&percnt; while the average battery lifetime is increased by 18&percnt;."}{"fieldName":"dc.title","informationCode":"WARN_TEXT_LENGTH_LARGE","handle":"12345678_acm\/6633","fieldValue":"Enhancing user experiences by exploiting energy and launch delay trade-off of mobile multimedia applications"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/6633","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6633","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/6634","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6634","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/6635","fieldValue":" In embedded systems, controlling a shared resource like a bus, or improving a property like power consumption, may be hard to achieve when programming device drivers individually. In this article, we propose a global resource control approach, based on a centralized view of the devices' states. The solution we propose operates on the hardware\/software interface. It involves a simple adaptation of the application level, to communicate with the hardware via a control layer. The control layer itself is built from a set of simple automata: the device drivers, whose states correspond to functional or power consumption modes, and a controller to enforce global properties. All these automata are programmed using a synchronous language, and compiled into a single piece of C code. We take as example the node of a sensor network. We explain the approach in details, demonstrate its use and benefits with an event-driven or multithreading operating system, and draw guidelines for its use in other contexts."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/6635","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6635","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/6636","fieldValue":" To compute a worst-case execution time (WCET) estimate for a program, the architectural effects of the underlying hardware must be modeled. For modern processors this results in the need for a cache and pipeline analysis. The timing-relevant result of the cache analysis is the categorization of the accesses to cached memory. Categorizations that are obtainable by the well-known must and may cache analysis [Ferdinand 1997] are always-hit, always-miss and not-classified. The cache persistence analysis tries to provide additional information for the not-classified case to limit the number of misses. There exists a cache persistence analysis by Ferdinand and Wilhelm based on abstract interpretation computing these classifications. In this article, we present a correctness issue with this analysis. To fix this issue, we propose two new abstract interpretation based persistence analyses and show their safety. One is based on the known may analysis and a second one on the concept of conflict counting. For fully timing compositional architectures [Wilhelm et al. 2009] the persistence information is straightforward to use. We will apply the concepts of persistence analysis for the first time to state-of-the-art architectures that exhibit both timing anomalies and domino effects. Such architectures do not allow the analyzer to quantify the costs of a single cache hit or miss in isolation. To make the usage of the persistence information feasible, we integrate the presented novel persistence analyses together with a novel path analysis approach into the industrially used WCET analyzer aiT."}