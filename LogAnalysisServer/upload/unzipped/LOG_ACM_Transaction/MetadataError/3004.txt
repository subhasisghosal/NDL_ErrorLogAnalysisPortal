{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/20000","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/20001","fieldValue":" We argue for the need of supporting a symmetric select construct, in which entry calls as well as accepts can be alternatives. We present several situations in which a symmetric select leads to a more natural programming style. We show that several semantic principles are violated by a nonsymmetric select, while being satisfied by a symmetric one. In particular, the suggested symmetric intertask communication mechanism is fully abstract and composable, and has a distributed termination rule which reduces the risk of deadlock. Our discussion is in terms of Ada#8482;."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/20001","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/20001","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/20002","fieldValue":"Boehm, Hans-Juergen"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/20002","fieldValue":" We present a different style of axiomatic definition for programming languages. It is oriented toward imperative languages, such as Algol 68, that do not distinguish between statements and expressions. Rather than basing the logic on a notion of pre- or postcondition, we use the value of a programming language expression as the underlying primitive.A number of language constructs are examined in this framework. We argue that this style of definition gives us a significantly different view of the notion of â\u20ACœeasy axiomatixability.â\u20AC? Side effects in expressions as well as aliasing between variables are shown to be â\u20ACœeasily axiomatizableâ\u20AC? in our system."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/20002","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/20002","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/20003","fieldValue":"de Bruin, Arie"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/20003","fieldValue":" DNP (dynamic networks of processes) is a variant of the language introduced by Kahn and MacQueen [11, 12]. In the language it is possible to create new processes dynamically. We present a complete, formal denotational semantics for the language, along the lines sketched by Kahn and MacQueen. An informal explanation of the formal semantics is also given."}