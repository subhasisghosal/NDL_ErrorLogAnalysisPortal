{"fieldName":"dc.subject","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/15173","fieldValue":"CAD"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/15173","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/15173","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/15174","fieldValue":" Ray tracers, which sample radiance, are usually regarded as offline rendering algorithms that are too slow for interactive use. In this article we present a system that exploits object-space, ray-space, image-space, and temporal coherence to accelerate ray tracing. Our system uses per-surface interpolants to approximate radiance both interactive and batch ray tracers.Our approach explicity decouples the two primary operations of a ray tracerâ\u20AC\u201Dshading and visibility determinationâ\u20AC\u201Dand accelerates each of them independently. Shading is accelerated by quadrilinearily interpolating lazily acquired radiance samples. Interpolation error does not exceed a user-specified bound, allowing the user to control performance\/quality tradeoffs. Error is bounded by adaptive sampling at discontinuities and radiance nonlinearities.Visibility determination at pixels is accelerated by reprojecting interpolants as the user's viewpoint changes. A fast scan-line alogoithm then achieves high performance without sacrificing image quality. For a smoothly varying viewpoint, the combination of lazy interpolants and projection substantially accelerates the ray tracer. Additionally, an efficient cache management algorithm keeps the memory footprint of the system small with negilgible overhead."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/15174","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/15174","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/2436","fieldValue":" We show how to construct an explicit Hamilton cycle in the directed Cayley graph $&Cayrarr;({Ïƒ_n, Ïƒnâˆ\u20191}: Sn), where Ïƒk$ is the rotation (1 2 &cdots; k). The existence of such cycles was shown by Jackson [1996] but the proof only shows that a certain directed graph is Eulerian, and Knuth [2005] asks for an explicit construction. We show that a simple recursion describes our Hamilton cycle and that the cycle can be generated by an iterative algorithm that uses O(n) space. Moreover, the algorithm produces each successive edge of the cycle in constant time; such algorithms are said to be loopless. Finally, our Hamilton cycle can be used to construct an explicit universal cycle for the (nâˆ\u20191)-permutations of a n-set, or as the basis of an efficient algorithm for generating every n-permutation of an n-set within a circular array or linked list."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/2436","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/2436","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/15175","fieldValue":" Heuristics that exploit bouning boxes are common in algorithms for rendering, modeling, and animation. While experience has shown that bounding boxes improve the performance of these algorithms in practice, the previous theoretical analysis has concluded that bounding boxes perform poorly in the worst case. This paper reconciles this discrepancy by analyzing intersections among n geometric objects in terms of two parameters: Î± an upper bound on the aspect ratio or elongatedness of each object; and &sgr; an upper bound on the scale factor or size disparity between the largest and smallest objects. Letting Ko and Kb be the number of intersecting object pairs and bounding box pairs, respectively, we analyze a ratio measure of the bounding boxes' efficiency, r=Kb\/n+Ko . The analysis proves that r=Oas log2s and r=Was . One important consequence is that if Î± and &sgr; are small constants (as is often the case in practice), thenKb= O(Ko)+O(n, so an algorithm that uses bounding boxes has time complexity proportional to the number of actual object intersections. This theoretical result validates the efficiency that bounding boxes have demonstrated in practice. Another consequence of our analysis is a proof of the output-sensitivity of an algorithm for reporting all intersecting pairs in a set of n convex polyhedra with constant Î± and &sgr;. The algorithm takes time O(nlogdâˆ\u20191n+Kologdâˆ\u20191n) for dimension d = 2, 3. This running time improves on the performance of previous algorithms, which make no assumptions about Î± and &sgr;."}