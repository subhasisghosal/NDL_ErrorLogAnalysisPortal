{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/21732","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/21733","fieldValue":"Lo, Chia-Tien Dan"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/21733","fieldValue":"Tai, Yi-Gang"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/21733","fieldValue":" With their expressiveness and simplicity, Perl compatible regular expressions (PCREs) have been adopted in mainstream signature based network intrusion detection systems (NIDSs) to describe known attack signatures, especially for polymorphic worms. NIDSs rely on an underlying string matching engine that simulates PCREs to inspect each network packet. PCRE is a superset of traditional regular expressions, and provides advanced features. However, this pattern matching becomes a performance bottleneck of software-based NIDSs, causing a big portion of their execution time to be dedicated to payload inspection, which results in an unacceptable packet drop rate. The penetration of these unexamined packets creates a security hole in such systems. Over the past decade, hardware acceleration for the pattern matching has been studied extensively and a marginal performance has been achieved. Among hardware approaches, FPGA-based acceleration engines provide great flexibility because new signatures can be compiled and programmed into their reconfigurable architecture. As more and more malicious signatures are discovered, it becomes harder to map a complete set of malicious signatures specified in PCREs to an FPGA chip. One of the space consuming components is the counter used in the constrained repetitions for PCREs. Therefore, we propose a space efficient SelectRAM counter for PCREs that use counting. The design takes advantage of the basic components contained in a configurable logic block, and thus optimizes space usage. A set of basic PCRE blocks has been built in hardware to implement PCREs. Experimental results show that the proposed scheme outperforms existing designs by at least fivefold."}{"fieldName":"dc.subject","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/21733","fieldValue":"FPGA"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/21733","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/21733","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/21734","fieldValue":" Coupling reconfigurable hardware accelerators with processors is an effective way to meet the performance and flexibility required to cope with modern embedded applications. The ARISE framework provides a systematic approach to extend a processor once. It will thereafter support the coupling of arbitrary hardware accelerators. The accelerators can be coupled as coprocessors or functional units of the processorâ\u20AC™s datapath, and therefore exploited as a hybrid, which includes both loose and tight computational models. This article presents a complete framework for developing applications on such hybrid reconfigurable ARISE machines. The framework integrates the automatic identification of custom instructions and the semiautomatic\/profiling-driven identification of coprocessors supporting the hybrid computational model. Moreover, it supports a modular design approach where the software and the hardware modules are developed independently and later ported into any ARISE machine with reconfigurable technology. To evaluate efficiency, a set of benchmarks is implemented on an ARISE evaluation machine utilizing the proposed framework. In addition, the ARISE machine is compared against a well-established processor paradigm that utilizes reconfigurable accelerators following only the typical coprocessor approach. Experimental results prove that the framework can be used to exploit the hybrid computational model and achieve significant performance improvements over the typical coprocessor acceleration approach. Moreover, results demonstrate how the framework can be used to trade off performance, silicon area, and application development time."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/21734","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/21734","fieldValue":"ACM"}