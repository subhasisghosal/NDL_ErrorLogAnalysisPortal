{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/11089","fieldValue":" jGRASP has three integrated approaches for interacting with its dynamic viewers for data structures: debugger, workbench, and text-based interactions that allow individual Java statements and expressions to be executed\/evaluated. These approaches can be used together to provide a complementary set of interactions with the dynamic viewers. Data structure identification and rendering were tested by examining examples from 20 data structure textbooks. Controlled experiments with CS2 students indicate that the viewers can have a significant positive impact on student performance. The overall result is a flexible environment for interacting with effective dynamic data structure visualizations generated by a robust structure identifier."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/11089","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/11089","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/11090","fieldValue":" There is an active research community concentrating on visualizations of algorithms taught in CS1 and CS2 courses. These visualizations can help students to create concrete visual images of the algorithms and their underlying concepts. Not only fundamental algorithms can be visualized, but also algorithms used in compilers. Visualizations that exist for use in compiler courses are mostly for the frontend, though. In this article we propose the use of visualizations for understanding optimization passes. Optimization passes are complex algorithms that operate on large amounts of code and it is not obvious when, where and how often each optimization is applied to the code. We show in this article how visualizations for a procedural abstraction optimization pass can capture the effect of all instances of this optimization over an entire program to make it easier for students to comprehend procedural abstraction."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/11090","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/11090","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/2010","fieldValue":" Schedulers used by modern OSs (e.g., Oracle Solaris 11â\u201E¢ and GNU\/Linux) balance load by balancing the number of threads in run queues of different cores. While this approach is effective for a single CPU multicore system, we show that it can lead to a significant load imbalance across CPUs of a multi-CPU multicore system. Because different threads of a multithreaded application often exhibit different levels of CPU utilization, load cannot be measured in terms of the number of threads alone. We propose Tumbler that migrates the threads of a multithreaded program across multiple CPUs to balance the load across the CPUs. While Tumbler distributes the threads equally across the CPUs, its assignment of threads to CPUs is aimed at minimizing the variation in utilization of different CPUs to achieve load balance. We evaluated Tumbler using a wide variety of 35 multithreaded applications, and our experimental results show that Tumbler outperforms both Oracle Solaris 11â\u201E¢ and GNU\/Linux."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/2010","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/2010","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/11091","fieldValue":" What is Computing Education Research (CER), why are we doing this type of research, and what should the community achieve? As associate editors to this special edition we provide our perspectives and discuss how they have influenced the evolution of the Koli Calling International Conference on Computing Education Research over the last nine years. The two articles in the special issue have been selected from among the twenty eight conference contributions for their originality and contribution to CER in the areas the Koli Calling Conference aims to emphasize. We hope that you find them inspiring reading."}