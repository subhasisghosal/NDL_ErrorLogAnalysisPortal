{"fieldName":"dc.relation.haspart","informationCode":"ERR_FORMAT_HASPART","handle":"12345678_acm\/11261","fieldValue":"[{\"visible\":false,\"sortKey\":\"October 2012\",\"expandable\":true,\"handle\":\"12345678_acm\/11315\",\"title\":\"Issue 4, October 2012\"},{\"visible\":false,\"sortKey\":\"August 2012\",\"expandable\":true,\"handle\":\"12345678_acm\/11314\",\"title\":\"Issue 3, August 2012\"},{\"visible\":false,\"sortKey\":\"April 2012\",\"expandable\":true,\"handle\":\"12345678_acm\/11313\",\"title\":\"Issue 2, April 2012\"},{\"visible\":false,\"sortKey\":\"January 2012\",\"expandable\":true,\"handle\":\"12345678_acm\/11312\",\"title\":\"Issue 1, January 2012\"}]"}{"fieldName":"dc.relation.haspart","informationCode":"ERR_FORMAT_HASPART","handle":"12345678_acm\/11262","fieldValue":"[{\"visible\":false,\"sortKey\":\"November 2013\",\"expandable\":true,\"handle\":\"12345678_acm\/11319\",\"title\":\"Issue 4, November 2013\"},{\"visible\":false,\"sortKey\":\"August 2013\",\"expandable\":true,\"handle\":\"12345678_acm\/11318\",\"title\":\"Issue 3, August 2013\"},{\"visible\":false,\"sortKey\":\"June 2013\",\"expandable\":true,\"handle\":\"12345678_acm\/11317\",\"title\":\"Issue 2, June 2013\"},{\"visible\":false,\"sortKey\":\"February 2013\",\"expandable\":true,\"handle\":\"12345678_acm\/11316\",\"title\":\"Issue 1, February 2013\"}]"}{"fieldName":"dc.relation.haspart","informationCode":"ERR_FORMAT_HASPART","handle":"12345678_acm\/11263","fieldValue":"[{\"visible\":false,\"sortKey\":\"August 2014\",\"expandable\":true,\"handle\":\"12345678_acm\/11323\",\"title\":\"Issue 4, August 2014\"},{\"visible\":false,\"sortKey\":\"July 2014\",\"expandable\":true,\"handle\":\"12345678_acm\/11322\",\"title\":\"Issue 3, July 2014\"},{\"visible\":false,\"sortKey\":\"April 2014\",\"expandable\":true,\"handle\":\"12345678_acm\/11321\",\"title\":\"Issue 2, April 2014\"},{\"visible\":false,\"sortKey\":\"February 2014\",\"expandable\":true,\"handle\":\"12345678_acm\/11320\",\"title\":\"Issue 1, February 2014\"}]"}{"fieldName":"dc.relation.haspart","informationCode":"ERR_FORMAT_HASPART","handle":"12345678_acm\/11264","fieldValue":"[{\"visible\":false,\"sortKey\":\"November 2015\",\"expandable\":true,\"handle\":\"12345678_acm\/11328\",\"title\":\"Issue 4, November 2015\"},{\"visible\":false,\"sortKey\":\"July 2015\",\"expandable\":true,\"handle\":\"12345678_acm\/11327\",\"title\":\"Issue 3, July 2015\"},{\"visible\":false,\"sortKey\":\"March 2015\",\"expandable\":true,\"handle\":\"12345678_acm\/11326\",\"title\":\"Issue 2, March 2015\"},{\"visible\":false,\"sortKey\":\"March 2015\",\"expandable\":true,\"handle\":\"12345678_acm\/11325\",\"title\":\"Issue 1, March 2015\"},{\"visible\":false,\"sortKey\":\"December 2014\",\"expandable\":true,\"handle\":\"12345678_acm\/11324\",\"title\":\"Issue 1, December 2014\"}]"}{"fieldName":"dc.relation.haspart","informationCode":"ERR_FORMAT_HASPART","handle":"12345678_acm\/11265","fieldValue":"[{\"visible\":false,\"sortKey\":\"November 2016\",\"expandable\":true,\"handle\":\"12345678_acm\/11333\",\"title\":\"Issue 4, November 2016\"},{\"visible\":false,\"sortKey\":\"July 2016\",\"expandable\":true,\"handle\":\"12345678_acm\/11332\",\"title\":\"Issue 3, July 2016\"},{\"visible\":false,\"sortKey\":\"March 2016\",\"expandable\":true,\"handle\":\"12345678_acm\/11331\",\"title\":\"Issue 2, March 2016\"},{\"visible\":false,\"sortKey\":\"December 2015\",\"expandable\":true,\"handle\":\"12345678_acm\/11330\",\"title\":\"Issue 2, December 2015\"},{\"visible\":false,\"sortKey\":\"December 2015\",\"expandable\":true,\"handle\":\"12345678_acm\/11329\",\"title\":\"Issue 1, December 2015\"}]"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/11334","fieldValue":" UNITY is an abstract formalism for proving properties of concurrent systems, which typically are expressed using guarded assignments [Chandy and Misra 1988]. UNITY has been mechanized in higher-order logic using Isabelle, a proof assistant. Safety and progress primitives, their weak forms (for the substitution axiom), and the program composition operator (union) have been formalized. To give a feel for the concrete syntax, this article presents a few extracts from the Isabelle definitions andproofs. It discusses a small example, two-process mutual exclusion. A mechanical theory of unions of programs supports a degree of compositional reasoning. Original work on extending program states is presented and then illustrated through a simple example involving an array of processes."}{"fieldName":"dc.subject","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/11334","fieldValue":"UNITY"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/11334","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/11334","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/11335","fieldValue":" The expressive power of first-order logic over finite structures is limited in two ways: it lacks a recursion mechanism, and it cannot count. Overcoming the first limitation has been a subject of extensive study. A number of fixpoint logics have been introduced. and shown to be subsumed by an infinitary logic $L^wâˆžw. This logic is easier to analyze than fixpoint logics, and it still lacks counting power, as it has a 0-1 law. On the counting side, there is no analog of Lwâˆžw . There are a number of logics with counting power, usually introduced via generalized quantifiers. Most known expressivityy bounds are based on the fact that counting extensions of first-order logic preserve the locality properties. This article has three main goals. First, we introduce a new logic L*âˆžw (C) that plays the same role for counting asLwâˆžw does for recursionâ\u20AC\u201Dit subsumes a number of extensions of first-order logic with counting, and has nice properties that make it easy to study. Second, we give simple direct proof thatLwâˆžw (C) expresses only local properties: those that depend on the properties of small neighborhoods, but cannot grasp a structure as a whole. This is a general way of saying that a logic lacks a recursion mechanism. Third, we consider a finer analysis of locality of counting logics. In particular, we address the question of how local a logic is, that is, how big are those neighborhoods that local properties depend on. We get a uniform answer for a variety of logics between first-order and L*âˆžw (C). This is done by introducing a new form of locality that captures the tightest condition that the duplicator needs to maintain in order to win a game. We also use this technique to give bounds on outputs of L*$âˆžw (C)-definable queries."}