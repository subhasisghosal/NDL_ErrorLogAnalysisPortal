{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/21928","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/21928","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/21929","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/21929","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/21930","fieldValue":" Although custom (and reconfigurable) computing can provide orders-of-magnitude improvements in energy efficiency and performance for many numeric, data-parallel applications, performance on nonnumeric, sequential code is often worse than conventional superscalar processors. This work attempts to improve sequential performance in custom hardware by (a) switching from a statically scheduled to a dynamically scheduled (dataflow) execution model and (b) developing a new compiler IR for high-level synthesisâ\u20AC\u201Dthe value state flow graph (VSFG)â\u20AC\u201Dthat enables aggressive exposition of ILP even in the presence of complex control flow. Compared to existing control-data flow graph (CDFG)-based IRs, the VSFG exposes more instruction-level parallelism from control-intensive sequential code by exploiting aggressive speculation, enabling control dependence analysis, as well as execution along multiple flows of control. This new IR is directly implemented as a static-dataflow graph in hardware by our prototype high-level synthesis tool chain and shows an average speedup of 1.13Ã\u2014 over equivalent hardware generated using LegUp, an existing CDFG-based HLS tool. Furthermore, the VSFG allows us to further trade area and energy for performance through loop unrolling, increasing the average speedup to 1.55Ã\u2014, with a peak speedup of 4.05Ã\u2014. Our VSFG-based hardware approaches the sequential cycle counts of an Intel Nehalem Core i7 processor while consuming only 0.25Ã\u2014 the energy of an in-order Altera Nios IIf processor."}{"fieldName":"dc.subject","informationCode":"ERR_FOUND_HTML_TAG","handle":"12345678_acm\/21930","fieldValue":"Amdahl&rsquo;s law"}{"fieldName":"dc.title","informationCode":"WARN_TEXT_LENGTH_LARGE","handle":"12345678_acm\/21930","fieldValue":"Value State Flow Graph: A Dataflow Compiler IR for Accelerating Control-Intensive Code in Spatial Hardware"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/21930","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/21930","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/21931","fieldValue":" Random numbers are important ingredients in a number of applications. Especially in a security context, they must be well distributed and unpredictable. We investigate the practical use of random number generators (RNGs) that are built from digital elements found in FPGAs. For this, we implement different types of ring oscillators (ROs) and memory collision-based circuits on FPGAs from major vendors. Implementing RNGs on the same device as the rest of the system benefits an overall reduction of vulnerability to attacks and wire tapping. Nevertheless, we investigate different attacks by tampering with power supply, chip temperature, and by exposition to strong magnetic fields and X-radiation. We also consider their usability as massively deployed components, whose functionality cannot be tested individually anymore, by conducting a technology invariance experiment. Our experiments show that BlockRAM-based RNGs cannot be considered as a suitable entropy source. We further show that RO-based RNGs work reliably under a wide range of operating conditions. While magnetic fields and X-rays did not induce any notable change, voltage and temperature variations caused an increase in propagation delays within the circuits. We show how reliable RNGs can be constructed and deployed on FPGAs."}