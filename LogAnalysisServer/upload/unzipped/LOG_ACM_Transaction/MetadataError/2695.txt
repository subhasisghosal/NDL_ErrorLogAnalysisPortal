{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18999","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/19000","fieldValue":" The IEEE 754 and 854 standards for floating-point arithmetic are essentially a specification of a programming environment, encompassing aspects from computer hardware, operating systems, and compilers to programming languages (see especially Section 8). Parts I and II of this paper together describe a tool to test floating-point implementations of arbitrary precision and exponent range (hardware as well as software) for compliance with the principles outlined in the IEEE standards. The tool consists of a driver program, together with a very large set of test vectors encoded in a precision-independent syntax. In Part I we have convered the testing of the basic operaitons +, âˆ\u2019, Ã\u2014, \/ and of the square root and remainder functions. In Part II we describe the extension of the test tool to deal with conversions between floating-point formats, conversions between floating-point and integer formats, the rounding of floating-point numbers to integral values, and binary-decimal conversions. Conversions can now be tested from a floating-point format of arbitrary precision and exponent range to another arbitrary smaller (larger) floating-point format as well as to and from fixed hardware integer formats. Conversion between the bases 2 and 10 can be tested for a number of precisions ranging from sing (24 bits), double (53 bits), long double or extended (64 bits) to quadruple (113 bits) precisioon and a proper multiprecision (240 bits) format. We conclude Part II with some applications of our test tool and report on the results of testing various floating-point implementations, meaning various language-compiler-hardware combinations as well as multiprecision libraries."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/19000","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/19000","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/19001","fieldValue":" The SLEIGN2 code is based on the ideas and methods of the original SLEIGN code of 1979. The main purpose of the SLEIGN2 code is to compute eigenvalues and eigenfunctions of regular and singular self-adjoint Sturm-Liouville problems, with both separated and coupled boundary conditions, and to approximate the continuous spectrum in the singular case. The code uses some new algorithms, which we describe, and has a driver program that offers a user-friendly interface. In this paper the algorithms and their implementations are discussed, and the class of problems to which each algorithm applied is identified."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/19001","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/19001","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/19002","fieldValue":" We present four basic Fortran subroutines for nondifferentiable optimization with simple bounds and general linear constraints. Subroutine PMIN, intended for minimax optimization, is based on a sequential quadratic programming variable metric algorithm. Subroutines PBUN and PNEW, intended for general nonsmooth problems, are based on bundle-type methods. Subroutine PVAR is based on special nonsmooth variable metric methods. Besides the description of methods and codes, we propose computational experiments which demonstrate the efficiency of this approach."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/19002","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/19002","fieldValue":"ACM"}