{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/1017","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/1017","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/1178","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/1178","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/2521","fieldValue":"Leiserson, Charles E"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/2521","fieldValue":" This article presents asymptotically optimal algorithms for rectangular matrix transpose, fast Fourier transform (FFT), and sorting on computers with multiple levels of caching. Unlike previous optimal algorithms, these algorithms are cache oblivious: no variables dependent on hardware parameters, such as cache size and cache-line length, need to be tuned to achieve optimality. Nevertheless, these algorithms use an optimal amount of work and move data optimally among multiple levels of cache. For a cache with size M and cache-line length B where M = $Î©(B^2$), the number of cache misses for an m Ã\u2014 n matrix transpose is Î˜(1 + mn\/B). The number of cache misses for either an n-point FFT or the sorting of n numbers is Î˜(1 + (n\/B)(1 + logM n)). We also give a Î˜(mnp)-work algorithm to multiply an m Ã\u2014 n matrix by an n Ã\u2014 p matrix that incurs Î˜(1 + (mn + np + mp)\/B + mnp\/BâˆšM) cache faults. We introduce an â\u20ACœideal-cacheâ\u20AC? model to analyze our algorithms. We prove that an optimal cache-oblivious algorithm designed for two levels of memory is also optimal for multiple levels and that the assumption of optimal replacement in the ideal-cache model can be simulated efficiently by LRU replacement. We offer empirical evidence that cache-oblivious algorithms perform well in practice."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/2521","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/2521","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/16046","fieldValue":" This article describes a computationally efficient formulation and an algorithm for tetrahedral finite-element simulation of elastic objects subject to Saint Venant-Kirchhoff (StVK) material law. The number of floating point operations required by the algorithm is in the range of 15&percnt; to 27&percnt; for computing the vertex forces from a given set of vertex positions, and 27&percnt; to 38&percnt; for the tangent stiffness matrix, in comparison to a well-optimized algorithm directly derived from the conventional Total Lagrangian formulation. In the new algorithm, the data is associated with edges and tetrahedron-sharing edge-pairs (TSEPs), as opposed to tetrahedra, to avoid redundant computation. Another characteristic of the presented formulation is that it reduces to that of a spring-network model by simply ignoring all the TSEPs. The technique is demonstrated through an interactive application involving haptic interaction, being combined with a linearized implicit integration technique employing a preconditioned conjugate gradient method."}{"fieldName":"dc.title","informationCode":"WARN_TEXT_LENGTH_LARGE","handle":"12345678_acm\/16046","fieldValue":"An edge-based computationally efficient formulation of Saint Venant-Kirchhoff tetrahedral finite elements"}