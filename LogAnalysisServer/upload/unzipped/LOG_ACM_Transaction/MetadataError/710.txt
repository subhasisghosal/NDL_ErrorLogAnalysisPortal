{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/13164","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/13164","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/13165","fieldValue":"Chang, Li-Pin"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/13165","fieldValue":"Du, Chun-Da"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/13165","fieldValue":" Solid-state disks (SSDs) are storage devices that emulate hard drives with flash memory. They have been widely deployed in mobile computers as disk drive replacements. Flash memory is organized in terms of erase blocks. With the current technology, a block can reach the end of its lifetime after thousands of erasure operations. Wear leveling is a technique to evenly erase the entire flash memory so that all blocks remain alive as long as possible. This study introduces a new wear-leveling algorithm based the observation that, under a real-life mobile PC's workload, most erasure operations are contributed by a small fraction of blocks. Our key ideas are 1) moving rarely updated data to a block that is extraordinarily worn and 2) avoiding repeatedly involving a block in wear-leveling activities. This study presents a successful implementation of the proposed wear-leveling algorithm using about 200 bytes of RAM in an SSD controller rated at 33 MHz. Evaluation results show that this algorithm achieves even wear of the entire flash memory while reducing the overheads of extra flash-memory operations."}{"fieldName":"dc.title","informationCode":"WARN_TEXT_LENGTH_LARGE","handle":"12345678_acm\/13165","fieldValue":"Design and implementation of an efficient wear-leveling algorithm for solid-state-disk microcontrollers"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/13165","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/13165","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/13166","fieldValue":" In enhanced-scan circuits, a two-pattern test < $t_i, tj > for a transition fault can be obtained by using a test tj that detects a stuck-at fault, and preceding it by a test ti that activates another stuck-at fault. Thus, test generation for transition faults can be done by combining pairs of stuck-at tests. This provides an alternative to deterministic test generation, as well as reduces the test storage requirements for transition fault tests. We study the possibility of generating scan-based tests for transition faults in standard-scan circuits in a similar way, by combining pairs of stuck-at tests. Since it is not always possible to obtain a standard-scan test that is equivalent to a two-pattern test < ti, tj > based on stuck-at tests ti and tj, it is not always possible to guarantee that the combination of ti and tj$ will detect a transition fault. To compensate for this, it is necessary to try combinations of different stuck-at test pairs, resulting in an increased simulation effort to compute effective standard-scan tests. Our focus in this work is on reducing this simulation effort by reducing the number of stuck-at test pairs that need to be considered."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/13166","fieldValue":"ACM"}