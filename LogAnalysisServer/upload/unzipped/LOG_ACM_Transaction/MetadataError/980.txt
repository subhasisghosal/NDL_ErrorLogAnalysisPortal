{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/14003","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/14004","fieldValue":" Batching yields significant savings in access costs in sequential, tree structured, and random files. A direct and simple expression is developed for computing the average number of records\/pages accessed to satisfy a batched query of a sequential tile. The advantages of batching for sequential and random files are discussed. A direct equation is provided for the number of nodes accessed in unhatched queries of hierarchical files. An exact recursive expression is developed for node accesses in batched queries of hierarchical files. In addition to the recursive relationship, good, closed-form upper- and lower-bound approximations are provided for the case of batched queries of hierarchical files."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/14004","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/14004","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/14005","fieldValue":" Database system support has become an essential part of many computer applications, which have extended beyond the more traditional commercial applications to, among others, engineering applications. Correspondingly, application programming with the need to access databases has progressively shifted to scientifically oriented languages.Modern developments in these languages are characterized by advanced mechanisms for the liberal declaration of data types, for type checking, and facilities for modularization of large programs. The present paper examines how a DBMS can be accessed from such a language in a way that conforms to its syntax and utilizes its type-checking facilities, without modifying the language specification itself, and hence its compilers. The basic idea is to rely on facilities for defining modules as separately compilable units, and to use these to declare user-defined abstract data types.The idea is demonstrated by an experiment in which a specific DBMS (ADABAS) is hosted in the programming language (LIS). The paper outlines a number of approaches and their problems, shows how to embed the DML into LIS, and how a more user-oriented DML can be provided in LIS."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/14005","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/14005","fieldValue":"ACM"}{"fieldName":"dc.relation.haspart","informationCode":"ERR_SPACE_MULTIPLE","handle":"12345678_acm\/13642","fieldValue":"[{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14006\",\"title\":\"An efficient I\/O interface for optical disks\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14007\",\"title\":\"Estimating the cost of updates in a relational database\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14008\",\"title\":\"Adaptive record clustering\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14009\",\"title\":\"Cautious transaction schedulers with admission control\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14010\",\"title\":\"GALILEO:  a strongly-typed, interactive conceptual language\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14011\",\"title\":\"Height-balanced trees of order (&#946;, &#947;, &#948;)\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14012\",\"title\":\"Comments on batched searching of sequential and tree-structured files\"}]"}{"fieldName":"dc.relation.haspart","informationCode":"WARN_JSON_MINIFY","handle":"12345678_acm\/13642","fieldValue":"[{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14006\",\"title\":\"An efficient I\/O interface for optical disks\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14007\",\"title\":\"Estimating the cost of updates in a relational database\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14008\",\"title\":\"Adaptive record clustering\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14009\",\"title\":\"Cautious transaction schedulers with admission control\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14010\",\"title\":\"GALILEO:  a strongly-typed, interactive conceptual language\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14011\",\"title\":\"Height-balanced trees of order (&#946;, &#947;, &#948;)\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/14012\",\"title\":\"Comments on batched searching of sequential and tree-structured files\"}]"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/14006","fieldValue":" We introduce the notion of an I\/O interface for optical digital (write-once) disks, which is quite different from earlier research. The purpose of an I\/O interface is to allow existing operating systems and application programs that use magnetic disks to use optical disks instead, with minimal change. We define what it means for an I\/O interface to be disk-efficient. We demonstrate a practical disk- efficient I\/O interface and show that its I\/O performance in many cases is optimum, up to a constant factor, among all disk-efficient interfaces. The interface is most effective for applications that are not update-intensive. An additional capability is a built-in history mechanism that provides software support for accessing previous versions of records. Even if not implemented, the I\/O interface can be used as a programming tool to develop efficient special purpose applications for use with optical disks."}