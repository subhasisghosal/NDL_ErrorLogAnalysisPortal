{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18758","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18758","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18759","fieldValue":" This paper describes two Fortran utilities for multiprecision computation. The first is a package of Fortran subroutines that perform a variety of arithmetic operations and transcendental functions on floating point numbers of arbitrarily high precision. This package is in some cases over 200 times faster than that of certain other packages that have been developed for this purpose.The second utility is a translator program, which facilitates the conversion of ordinary Fortran programs to use this package. By means of source directives (special comments) in the original Fortran program, the user declares the precision level and specifies which variables in each subprogram are to be treated as multiprecision. The translator program reads this source program and outputs a program with the appropriate multiprecision subroutine calls.This translator supports multiprecision integer, real, and complex datatypes. The required array space for multiprecision data types is automatically allocated. In the evaluation of computational expressions, all of the usual conventions for operator precedence and mixed mode operations are upheld. Furthermore, most of the Fortran-77 intrinsics, such as ABS, MOD, NINT, COS, EXP are supported and produce true multiprecision values."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18759","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18759","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18760","fieldValue":" An adaptive algorithm for computing an approximation to the integral of each element in a vector of functions over a 3-dimensional region covered by simplices is presented. The algorithm is encoded in FORTRAN 77.Locally, a cubature formula of degree 8 with 43 points is used to approximate an integral. The local error estimate is based on the same evaluation points. The error estimation procedure tries to decide whether the approximation for each function has asymptotic behavior, and different actions are taken depending on that decision.The simplex with the largest error is subdivided into 8 simplices. The local procedure is then applied to each new region. This procedure is repeated until convergence."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18760","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18760","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18761","fieldValue":" Three frequently used methods for numerically inverting Laplace transforms are tested on complicated transforms taken from the literature. The first method is a straightforward application of the trapezoidal rule to Bromwich's integral. The second method, developed by Weeks [22], integrates Bromwich's integral by using Laguerre polynomials. The third method, devised by Talbot [18], deforms Bromwich's contour so that the integrand of Bromwich's integral is small at the beginning and end of the contour. These methods are also applied to joint Laplace-Fourier transform problems. All three methods give satisfactory results; Talbot's, however, has an accurate method for choosing required parameters."}{"fieldName":"dc.title","informationCode":"WARN_TEXT_LENGTH_LARGE","handle":"12345678_acm\/18761","fieldValue":"On the numerical inversion of Laplace transforms: comparison of three new methods on characteristic problems from applications"}