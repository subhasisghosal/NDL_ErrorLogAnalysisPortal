{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6717","fieldValue":"ACM"}{"fieldName":"dc.relation.haspart","informationCode":"ERR_FORMAT_HASPART","handle":"12345678_acm\/1056","fieldValue":"[{\"visible\":false,\"sortKey\":\"October 2011\",\"expandable\":true,\"handle\":\"12345678_acm\/1083\",\"title\":\"Issue 4, October 2011\"},{\"visible\":false,\"sortKey\":\"September 2011\",\"expandable\":true,\"handle\":\"12345678_acm\/1082\",\"title\":\"Issue 3, September 2011\"},{\"visible\":false,\"sortKey\":\"June 2011\",\"expandable\":true,\"handle\":\"12345678_acm\/1081\",\"title\":\"Issue 2, June 2011\"},{\"visible\":false,\"sortKey\":\"February 2011\",\"expandable\":true,\"handle\":\"12345678_acm\/1080\",\"title\":\"Issue 1, February 2011\"}]"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/1616","fieldValue":" It has long been known that a fixed ordering of optimization phases will not produce the best code for every application. One approach for addressing this phase-ordering problem is to use an evolutionary algorithm to search for a specific sequence of phases for each module or function. While such searches have been shown to produce more efficient code, the approach can be extremely slow because the application is compiled and possibly executed to evaluate each sequence's effectiveness. Consequently, evolutionary or iterative compilation schemes have been promoted for compilation systems targeting embedded applications where meeting strict constraints on execution time, code size, and power consumption is paramount and longer compilation times may be tolerated in the final stage of development, when an application is compiled one last time and embedded in a product. Unfortunately, even for small embedded applications, the search process can take many hours or even days making the approach less attractive to developers. In this paper, we describe two complementary general approaches for achieving faster searches for effective optimization sequences when using a genetic algorithm. The first approach reduces the search time by avoiding unnecessary executions of the application when possible. Results indicate search time reductions of 62&percnt;, on average, often reducing searches from hours to minutes. The second approach modifies the search so fewer generations are required to achieve the same results. Measurements show this approach decreases the average number of required generations by 59&percnt;. These improvements have the potential for making evolutionary compilation a viable choice for tuning embedded applications."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/1616","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/1616","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/6718","fieldValue":"Chang, Yuan-Hao"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/6718","fieldValue":"Yang, Ming-Chang"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/6718","fieldValue":"Kuo, Tei-Wei"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/6718","fieldValue":"Hwang, Ren-Hung"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/6718","fieldValue":" Although flash memory has gained very strong momentum in the storage market, the reliability of flash-memory chips has been dropped significantly in the past years. This article presents a reliability enhancement design under the flash management layer (i.e., flash translation layer) to address this concern so as to reduce the design complexity of flash-memory management software\/firmware and to improve the maintainability and portability of existing and future products. In particular, a log-based write strategy with a hash-based caching policy is proposed to provide extra ECC redundancy and performance improvement. Strategies for bad block management are also presented. The failure rate of flash-memory storage systems is analyzed with the considerations of bit errors. The proposed design is later evaluated by a series of experiments based on realistic traces. It was shown that the proposed approach could significantly improve the reliability of flash memory with very limited system overheads."}