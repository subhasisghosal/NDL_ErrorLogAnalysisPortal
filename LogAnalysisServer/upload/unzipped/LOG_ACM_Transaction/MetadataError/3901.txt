{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/22624","fieldValue":" Informally, a call graph represents calls between entities in a given program. The call graphs that compilers compute to determine the applicability of an optimization must typically be conservative: a call may be omitted only if it can never occur in any execution of the program. Numerous software engineering tools also extract call graphs with the expectation that they will help software engineers increase their understanding of a program. The requirements placed on software engineeringtools that compute call graphs are typically more relaxed than for compilers. For example, some false negativesâ\u20AC\u201Dcalls that can in fact take place in some execution of the program, but which are omitted from the call graphâ\u20AC\u201Dmay be acceptable, depending on the understanding task at hand. In this article, we empirically show a consequence of this spectrum of requirements by comparing the C call graphs extracted from three software systems (mapmaker, mosaic, and gcc) by nine tools (cflow, cawk, CIA, Field, GCT, Imagix, LSME, Mawk, and Rigiparse). A quantitative analysis of the call graphs extracted for each system shows considerable variation, a result that is counterintuitive to many experienced software engineers. A qualitative analysis of these results reveals a number of reasons for this variation: differing treatments of macros, function pointers, input formats, etc. The fundamental problem is not that variances among the graphs extracted by different tools exist, but that software engineers have little sense of the dimensions of approximation in any particular call graph. In this article, we describe and discuss the study, sketch a design space for static call graph extractors, and discuss the impact of our study on practitioners, tool developers, and researchers. Although this article considers only one kind of information, call graphs, many of the observations also apply to static extractors of other kinds of information, such as inheritance structures, file dependences, and references to global variables."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/22624","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/22624","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/22625","fieldValue":"Vo, Kiem-Phong"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/22625","fieldValue":" Delta algorithms compress data by encoding one file in terms of another. This type of compression is useful in a number of situations: strong multiple versions of data, displaying differences, merging changes, distributing updates, storing backups, transmitting video sequences, and others. This article studies the performance parameters of several delta algorithms, using a benchmark of over 1,300 pairs of files taken from two successive releases of GNU software. Results indicate that modern delta compression algorithms based on Ziv-Lempel techniques significantly outperform diff, a popular but older delta compressor, in terms of compression ratio. The modern compressors also correlate better with the actual difference between files without sacrificing performance."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/22625","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/22625","fieldValue":"ACM"}{"fieldName":"dc.relation.haspart","informationCode":"ERR_SPACE_MULTIPLE","handle":"12345678_acm\/22467","fieldValue":"[{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/22626\",\"title\":\"Discovering models of software processes from event-based data\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/22627\",\"title\":\"In black and white: an integrated approach to class-level testing of object-oriented programs\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/22628\",\"title\":\"Formalizing space shuttle  software requirements: four case studies\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/22629\",\"title\":\"Errata: a formal basis for architectural connection\"}]"}{"fieldName":"dc.relation.haspart","informationCode":"WARN_JSON_MINIFY","handle":"12345678_acm\/22467","fieldValue":"[{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/22626\",\"title\":\"Discovering models of software processes from event-based data\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/22627\",\"title\":\"In black and white: an integrated approach to class-level testing of object-oriented programs\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/22628\",\"title\":\"Formalizing space shuttle  software requirements: four case studies\"},{\"visible\":true,\"expandable\":false,\"handle\":\"12345678_acm\/22629\",\"title\":\"Errata: a formal basis for architectural connection\"}]"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/22626","fieldValue":" Many software process methods and tools presuppose the existence of a formal model of a process. Unfortunately, developing a formal model for an on-going, complex process can be difficult, costly, and error prone. This presents a practical barrier to the adoption of process technologies, which would be lowered by automated assistance in creating formal models. To this end, we have developed a data analysis technique that we term process discovery. Under this technique, data describing process events are first captured from an on-going process and then used to generate a formal model of the behavior of that process. In this article we describe a Markov method that we developed specifically for process discovery, as well as describe two additional methods that we adopted from other domains and augmented for our purposes. The three methods range from the purely algorithmic to the purely statistical. We compare the methods and discuss their application in an industrial case study."}