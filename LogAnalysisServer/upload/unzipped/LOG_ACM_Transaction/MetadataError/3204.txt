{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/20556","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/20557","fieldValue":" Single-language runtime systems, in the form of Java virtual machines, are widely deployed platforms for executing untrusted mobile code. These runtimes provide some of the features that operating systems provide: interapplication memory protection and basic system services. They do not, however, provide the ability to isolate applications from each other. Neither do they provide the ability to limit the resource consumption of applications. Consequently, the performance of current systems degrades severely in the presence of malicious or buggy code that exhibits ill-behaved resource usage. We show that Java runtime systems can be extended to support processes, and that processes can provide robust and efficient support for untrusted applications.We have designed and built KaffeOS, a Java runtime system that provides support for processes. KaffeOS isolates processes and manages the physical resources available to them: CPU and memory. Unlike existing Java virtual machines, KaffeOS can safely terminate processes without adversely affecting the integrity of the system, and it can fully reclaim a terminated process's resources. Finally, KaffeOS requires no changes to the Java language. The novel aspects of the KaffeOS architecture include the application of a user\/kernel boundary as a structuring principle for runtime systems, the employment of garbage collection techniques for resource management and isolation, and a model for direct sharing of objects between untrusted applications. The difficulty in designing KaffeOS lay in balancing the goals of isolation and resource management against the goal of allowing direct sharing of objects.For the SpecJVM benchmarks, the overhead that our KaffeOS prototype incurs ranges from 0&percent; to 25&percent;, when compared to the open-source JVM on which it is based. We consider this overhead acceptable for the safety that KaffeOS provides. In addition, our KaffeOS prototype can scale to run more applications than running multiple JVMs. Finally, in the presence of malicious or buggy code that engages in a denial-of-service attack, KaffeOS can contain the attack, remove resources from the attacked applications, and continue to provide robust service to other clients."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/20557","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/20557","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/20558","fieldValue":" Dynamic slicing algorithms are used to narrow the attention of the user or an algorithm to a relevant subset of executed program statements. Although dynamic slicing was first introduced to aid in user level debugging, increasingly applications aimed at improving software quality, reliability, security, and performance are finding opportunities to make automated use of dynamic slicing. In this paper we present the design and evaluation of three precise dynamic data slicing algorithms called the full preprocessing (FP), no preprocessing (NP) and limited preprocessing (LP) algorithms. The algorithms differ in the relative timing of constructing the dynamic data dependence graph and its traversal for computing requested dynamic data slices. Our experiments show that the LP algorithm is a fast and practical precise data slicing algorithm. In fact we show that while precise data slices can be orders of magnitude smaller than imprecise dynamic data slices, for small number of data slicing requests, the LP algorithm is faster than an imprecise dynamic data slicing algorithm proposed by Agrawal and Horgan."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/20558","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/20558","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/1216","fieldValue":" Autonomic communications aim at easing the burden of managing complex and dynamic networks, and designing adaptive, self-turning and self-stabilizing networks to provide much needed flexibility and functional scalability. With the ever-increasing number of multicast applications made recently, considerable efforts have been focused on the design of adaptive flow control schemes for autonomic multicast services. The main difficulties in designing an adaptive flow controller for autonomic multicast service are caused by heterogeneous multicast receivers, especially those with large propagation delays, since the feedback arriving at the source is somewhat outdated and can be harmful to the control operations. To tackle the preceding problem, this article describes a novel, adaptive, and autonomic multicast scheme, the so-called Proportional, Integrative, Derivative plus Neural Network (PIDNN) predictive technique, which consists of two components: the Proportional Integrative plus Derivative (PID) controller and the Back Propagation BP Neural Network (BPNN). In this integrated scheme, the PID controllers are located at the next upstream main branch nodes of the multicast receivers, and have explicit rate algorithms to regulate the receiving rates of the receivers; while the BPNN is located at the multicast source, and predicts the available bandwidth of those longer delay receivers to compute the expected rates of the longer delay receivers. The ultimate sending rate of the multicast source is the maximum of the aforesaid receiving rates that can be accommodated by its participating branches. This network-assisted property is different from the existing control schemes, in that the PIDNN controller can release the irresponsiveness of a multicast flow caused by those long propagation delays from the receivers. By using BPNN, this active scheme makes the control more responsive to the receivers with longer propagation delay. Thus the rate adaptation can be performed in a timely manner, for the sender to respond to network congestion quickly. We analyze the theoretical aspects of the proposed algorithm, show how the control mechanism can be used to design a controller to support multirate multicast transmission based on feedback of explicit rates, and verify this matching using simulations. Simulation results demonstrate that the proposed PIDNN controller avoids overflow of multicast traffic, and performs better than the existing scheme PNN [Tan et al. 2005] and the multicast schemes based on control theory. Moreover, it also performs well in the sense that it achieves high link utilization, quick response, good scalability, high unitary throughput, intra-session fairness and inter-session fairness."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/1216","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/1216","fieldValue":"ACM"}