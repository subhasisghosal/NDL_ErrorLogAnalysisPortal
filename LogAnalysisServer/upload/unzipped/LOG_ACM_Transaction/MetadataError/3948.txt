{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/22746","fieldValue":" Embedded real-time systems consist of hardware and software that controls the behavior of a device or plant. They are ubiquitous in today's technological landscape and found in domains such as telecommunications, nuclear power, avionics, and medical technology. These systems are difficult to design and build because they must satisfy both functional and timing requirements to work correctly in their intended environment. Furthermore, embedded systems are often critical systems, where failure can lead to loss of life, loss of mission, or serious financial consequences. Because of the difficulty in creating these systems and the consequences of failure, they require rigorous and reliable design approaches. The synchronous approach is one possible answer to this demand. Its mathematical basis provides formal concepts that favor the trusted design of embedded real-time systems. The multiclock or polychronous model stands out from other synchronous specification models by its capability to enable the design of systems where each component holds its own activation clock as well as single-clocked systems in a uniform way. A great advantage is its convenience for component-based design approaches that enable modular development of increasingly complex modern systems. The expressiveness of its underlying semantics allows dealing with several issues of real-time design. This article exposes insights gained during recent years from the design of real-time applications within the polychronous framework. In particular, it shows promising results about the design of applications from the avionics domain."}{"fieldName":"dc.subject","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/22746","fieldValue":"IMA"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/22746","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/22746","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/3219","fieldValue":" Human haptic performance is not fixed, but subject to major alterations through learning processes. We describe a new stimulation protocol that allows to improve haptic performance in humans in a highly systemic way through unattended activation-based learning. The so-called coactivation protocol is based upon temporal constraints of Hebbian learning where simultaneity plays a key role for the induction of plastic changes. We provide an overview about the potential of coactivation by summarizing recent findings showing that coactivation alters a broad range of basic as well as cognitively demanding types of haptic performance in parallel to cortical reorganization in somatosensory cortex. For example, coactivation applied to the tip of the index finger, or to all fingers of the dominant hand improves tactile acuity, but also haptic object recognition, and speeds up multiple-choice reaction times. Because such changes persist between 24 h and 1 week without further intervention, we interpret the underlying processes as a particular form of perceptual learning. We describe results where coactivation has been utilized for therapeutical purposes in impaired human populations, we outline new developments to optimize and extend unattended activation-based learning protocols, and we sketch the next steps necessary to apply the concept of unattended activation-based learning on a regular and reliable basis as a therapeutical tool in order to selectively interfere with impaired haptic performance."}{"fieldName":"dc.title","informationCode":"WARN_TEXT_LENGTH_LARGE","handle":"12345678_acm\/3219","fieldValue":"Improving human haptic performance in normal and impaired human populations through unattended activation-based learning"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/3219","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/3219","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/22747","fieldValue":" Fault-based testing of software checks the software implementation for a set of faults. Two previous papers on fault-based testing [Kuhn 1999; Tsuchiya and Kikuno 2002] represent the required behavior of the software as a Boolean specification represented in Disjunctive Normal Form (DNF) and then show that faults may be organized in a hierarchy. This article extends these results by identifying necessary and sufficient conditions for fault-based testing. Unlike previous solutions, the formal analysis used to derive these conditions imposes no restrictions (such as DNF) on the form of the Boolean specification."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/22747","fieldValue":"ACM"}