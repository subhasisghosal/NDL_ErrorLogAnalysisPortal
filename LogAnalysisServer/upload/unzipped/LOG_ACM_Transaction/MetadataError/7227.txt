{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/1120","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/1120","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/1836","fieldValue":" The compiler optimizations we enable and the order in which we apply them on a program have a substantial impact on the program execution time. Compilers provide default optimization sequences which can give good program speedup. As the default sequences have to optimize programs with different characteristics, they embed in them multiple subsequences which can optimize different classes of programs. These multiple subsequences may falsely interact with each other and affect the potential program speedup achievable. Instead of searching for a single universally optimal sequence, we can construct a small set of good sequences such that for every program class there exists a near-optimal optimization sequence in the good sequences set. If we can construct such a good sequences set which covers all the program classes in the program space, then we can choose the best sequence for a program by trying all the sequences in the good sequences set. This approach completely circumvents the need to solve the program classification problem. Using a sequence set size of around 10 we got an average speedup up to 14&percnt; on PolyBench programs and up to 12&percnt; on MiBench programs. Our approach is quite different from either the iterative compilation or machine-learning-based prediction modeling techniques proposed in the literature so far. We use different training and test datasets for cross-validation as against the Leave-One-Out cross-validation technique."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/1836","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/1836","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/9272","fieldValue":" We consider a single node which multiplexes a large number of traffic sources. We ask a simple question: how do the optimal allocations of bandwidth and buffer vary with the number of sources? We investigate this issue using previous results on the probability of overflow for an aggregate of i.i.d. flows, e.g., overflow resulting from effective bandwidth models. We wish to determine the variation of the minimum cost allocations of bandwidth and buffer with the number of sources, given a cost per unit of each resource. We first consider a class of ON\/OFF fluid flows. We find that the optimal bandwidth allocation above the mean rate and the optimal buffer allocation are both proportional to the square root of the number of sources. Correspondingly, we find that the excess cost incurred by a fixed buffer allocation or by linear buffer allocations is proportional to the square of the percentage difference between the assumed number of sources and the actual number of sources and to the square root of the number of sources. We next consider a class of general i.i.d. sources for which the aggregate effective bandwidth is a decreasing convex function of buffer and linearly proportional to the number of sources. We find that the optimal buffer allocation is strictly increasing with the number of sources. Correspondingly, we find that the excess cost incurred by a fixed buffer allocation is an increasing convex function of the difference between the assumed number of sources and the actual number of sources."}{"fieldName":"dc.identifier.other","informationCode":"ERR_NULL_VALUE","handle":"12345678_acm\/9272","fieldValue":"{\"eissn\":\"\"}"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/9272","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/9272","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/9273","fieldValue":"Ho, Pin-Han"}