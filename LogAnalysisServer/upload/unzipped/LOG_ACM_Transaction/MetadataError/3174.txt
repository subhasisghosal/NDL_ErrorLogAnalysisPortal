{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/20473","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/20474","fieldValue":" We describe a mechanically checked proof of a property of a small system of Java programs involving an unbounded number of threads and synchronization, via monitors. We adopt the output of the javac compiler as the semantics and verify the system at the bytecode level under an operational semantics for the JVM. We assume a sequentially consistent memory model and atomicity at the bytecode level. Our operational semantics is expressed in ACL2, a Lisp-based logic of recursive functions. Our proofs are checked with the ACL2 theorem prover. The proof involves reasoning about arithmetic; infinite loops; the creation and modification of instance objects in the heap, including threads; the inheritance of fields from superclasses; pointer chasing and smashing; the invocation of instance methods (and the concomitant dynamic method resolution); use of the start method on thread objects; the use of monitors to attain synchronization between threads; and consideration of all possible interleavings (at the bytecode level) over an unbounded number of threads. Readers familiar with monitor-based proofs of mutual exclusion will recognize our proof as fairly classical. The novelty here comes from (i) the complexity of the individual operations on the abstract machine; (ii) the dependencies between Java threads, heap objects, and synchronization; (iii) the bytecode-level interleaving; (iv) the unbounded number of threads; (v) the presence in the heap of incompletely initialized threads and other objects; and (vi) the proof engineering permitting automatic mechanical verification of code-level theorems. We discuss these issues. The problem posed here is also put forth as a benchmark against which to measure other approaches to formally proving properties of multithreaded Java programs."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/20474","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/20474","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/20475","fieldValue":" Shape analysis concerns the problem of determining \"shape invariants\" for programs that perform destructive updating on dynamically allocated storage. This article presents a parametric framework for shape analysis that can be instantiated in different ways to create different shape-analysis algorithms that provide varying degrees of efficiency and precision. A key innovation of the work is that the stores that can possibly arise during execution are represented (conservatively) using 3-valued logical structures. The framework is instantiated in different ways by varying the predicates used in the 3-valued logic. The class of programs to which a given instantiation of the framework can be applied is not limited a priori (i.e., as in some work on shape analysis, to programs that manipulate only lists, trees, DAGS, etc.); each instantiation of the framework can be applied to any program, but may produce imprecise results (albeit conservative ones) due to the set of predicates employed."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/20475","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/20475","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/20476","fieldValue":" The Eighth International Workshop on Foundations of Object-Oriented Languages (FOOL 8) was held on January 20, 2001, colocated with the ACM Symposium on Principles of Programming Languages in London. Kathleen Fisher chaired the program committee. Six contributed papers were presented. After the workshop, extended versions of three were solicited for this special issue of TOPLAS; the two articles that were ultimately submitted were reviewed, revised, and accepted following standard TOPLAS procedures.The special issue opens with Type-Preserving Compilation of Featherweight Java by Christopher League, Zhong Shao, and Valery Trifonov. The goal of the authors is to establish a foundation for certifying compilation of Java-like class-based languages. To this end, the authors give an encoding of core Java features in a typed intermediate language suitable for use within a type-preserving compiler. Because of its intended use, the authors focus on developing an efficient encoding. They show that the type erasure of their implementation matches the standard vtable self-application semantics of message sending.The authors use Featherweight Java (FJ), which models the core features of Java, as their source language. Their translation targets a variant of FÏ\u2030, already implemented as part of the SML\/NJ compiler, using its row polymorphism and existential and recursive types to encode FJ. The authors show that the translation from FJ to their target preserves types.In the issue's second article, More Dynamic Object Reclassification: FickleII, Sophia Drossopoulou, Ferruccio Damiani, Mariangiola Dezani-Ciancaglini, and Paola Giannini explore the issue of dynamic reclassification, by which an object changes its class membership at runtime while retaining its identity. This ability helps model real-world situations where an object has different roles over time---for example, a person who is first a student and then graduates to become a teacher.The authors focus their study on the design of a language, FickleII, which extends an imperative, typed, class-based, object-oriented language with a reclassification operation. To specify the behavior of their language, the authors give an operational semantics. They then develop a type and effect system and show that the type system is sound, in the sense that a well-typed program cannot get stuck under the operational semantics.We would like to thank our colleagues who served on the FOOL 8 program committee and those who participated in the anonymous reviewing process for TOPLAS. Their efforts contributed greatly to the quality of this special issue."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/20476","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/20476","fieldValue":"ACM"}