{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/21097","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/21097","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/21098","fieldValue":" Storage workload identification is the task of characterizing a workload in a storage system (more specifically, network storage systemâ\u20AC\u201DNAS or SAN) and matching it with the previously known workloads. We refer to storage workload identification as â\u20ACœworkload identificationâ\u20AC? in the rest of this article. Workload identification is an important problem for cloud providers to solve because (1) providers can leverage this information to colocate similar workloads to make the system more predictable and (2) providers can identify workloads and subsequently give guidance to the subscribers as to associated best practices (with respect to configuration) for provisioning those workloads. Historically, people have identified workloads by looking at their read\/write ratios, random\/sequential ratios, block size, and interarrival frequency. Researchers are well aware that workload characteristics change over time and that one cannot just take a point in time view of a workload, as that will incorrectly characterize workload behavior. Increasingly, manual detection of workload signature is becoming harder because (1) it is difficult for a human to detect a pattern and (2) representing a workload signature by a tuple consisting of average values for each of the signature components leads to a large error. In this article, we present workload signature detection and a matching algorithm that is able to correctly identify workload signatures and match them with other similar workload signatures. We have tested our algorithm on nine different workloads generated using publicly available traces and on real customer workloads running in the field to show the robustness of our approach."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/21098","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/21098","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/21099","fieldValue":" NAND flash-based Solid-State Drives (SSDs) are becoming a viable alternative as a secondary storage solution for many computing systems. Since the physical characteristics of NAND flash memory are different from conventional Hard-Disk Drives (HDDs), flash-based SSDs usually employ an intermediate software layer, called a Flash Translation Layer (FTL). The FTL runs several firmware algorithms for logical-to-physical mapping, I\/O interleaving, garbage collection, wear-leveling, and so on. These FTL algorithms not only have a great effect on storage performance and lifetime, but also determine hardware cost and data integrity. In general, a hybrid FTL scheme has been widely used in mobile devices because it exhibits high performance and high data integrity at a low hardware cost. Recently, a demand-based FTL based on page-level mapping has been rapidly adopted in high-performance SSDs. The demand-based FTL more effectively exploits the device-level parallelism than the hybrid FTL and requires a small amount of memory by keeping only popular mapping entries in DRAM. Because of this caching mechanism, however, the demand-based FTL is not robust enough for power failures and requires extra reads to fetch missing mapping entries from NAND flash. In this article, we propose a new flash translation layer called LAST++. The proposed LAST++ scheme is based on the hybrid FTL, thus it has the inherent benefits of the hybrid FTL, including low resource requirements, strong robustness for power failures, and high read performance. By effectively exploiting the locality of I\/O references, LAST++ increases device-level parallelism and reduces garbage collection overheads. This leads to a great improvement of I\/O performance and makes it possible to overcome the limitations of the hybrid FTL. Our experimental results show that LAST++ outperforms the demand-based FTL by 27&percnt; for writes and 7&percnt; for reads, on average, while offering higher robustness against sudden power failures. LAST++ also improves write performance by 39&percnt;, on average, over the existing hybrid FTL."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/21099","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/21099","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/1221","fieldValue":" Although previous bio-inspired models have concentrated on invertebrates, such as ants, mammals, such as primates with higher cognitive function, are valuable for modeling the increasingly complex problems in engineering. Understanding primatesâ\u20AC™ social and communication systems and applying what is learned from them to engineering domains will likely lead to solutions to a number of problems. Scent-marking is an important behavior among primates and many other mammals. In this article, inspired by primatesâ\u20AC™ scent-marking activity, we propose and study a collaboration strategy for mobile and static sensors with RFID tags, where mobile sensors can be treated as robots or mobile actuators and can leave information to direct others to find them. Mobile sensors are equipped with RFID tags (or sensors) that can be deployed whenever needed, and RFID tags (or sensors) carry related information for other robots to pick up. We propose several primate-inspired communication mechanisms, including delayed-and-relayed and scent-trail communication among robots. We analytically model and simulate scent-trail communication. We also study a tracking and pursuing scheme of mobile sensors using simulations in terms of robot speeds, searching function, deployment density, turning function, and so on. We assume that robots (mobile sensors or mobile actuators) are capable of deploying\/throwing-out sensors\/RFID tags."}{"fieldName":"dc.subject","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/1221","fieldValue":"RFID"}