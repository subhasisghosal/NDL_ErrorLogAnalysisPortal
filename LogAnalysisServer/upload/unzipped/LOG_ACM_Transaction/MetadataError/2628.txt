{"fieldName":"dc.subject","informationCode":"ERR_FOUND_HTML_TAG","handle":"12345678_acm\/18825","fieldValue":"Levin's <italic>u<\/italic> transform"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18825","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18825","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18826","fieldValue":" Automatic differentiation is an interesting and important tool for all numerical algorithms that require derivatives, e.g., in nonlinear programming, optimal control, parameter estimation, and differential equations. The basic idea is to avoid not only numerical approximations, which are expensive with respect to CPU time and contain round-off errors, but also hand-coded differentiation. This article introduces the forward and backward accumulation methods and describes the numerical implementation of a computer code with the name PCOMP. The main intention of the approach used is to provide a flexible and portable Fortran code for practical applications. The underlying language is described in terms of a formal grammar and is a subset of Fortran with a few extensions. Besides a parser that generates an intermediate code and that can be executed independently from the evaluation routines, there are other subroutines for the direct computation of function and gradient values, which can be called directly from a user program. On the other hand, it is possible to generate a Fortran code for function and gradient evaluation that can be compiled and linked separately."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/18826","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/18826","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/2823","fieldValue":" In Chinese languages, tones carry important information at various linguistic levels. This research is based on the belief that tone information, if acquired accurately and utilized effectively, contributes to the automatic speech recognition of Chinese. In particular, we focus on the Cantonese dialect, which is spoken by tens of millions of people in Southern China and Hong Kong. Cantonese is well known for its complicated tone system, which makes automatic tone recognition very difficult. This article describes an effective approach to explicit tone recognition of Cantonese in continuously spoken utterances. Tone feature vectors are derived, on a short-time basis, to characterize the syllable-wide patterns of F0 (fundamental frequency) and energy movements. A moving-window normalization technique is proposed to reduce the tone-irrelevant fluctuation of F0 and energy features. Hidden Markov models are employed for context-dependent acoustic modeling of different tones. A tone recognition accuracy of 66.4% has been achieved in the speaker-independent case. The recognized tone patterns are then utilized to assist Cantonese large-vocabulary continuous speech recognition (LVCSR) via a lattice expansion approach. Experimental results show that reliable tone information helps to improve the overall performance of LVCSR."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/2823","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/2823","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/18827","fieldValue":" This article presents a survey on the innovative features of a handful of languages that offer new features that can be valuable in numerical analysis, and a survey of the pros and cons of the languages with regards to work in numerical analysis. Language features such as polymorphism, first-class functions, and object-oriented programming offer improved writability, readability, reliability, and maintenance of computer software. The article discusses language features and uses, and includes a comparison of current implementations. It is intended both as an introduction to nonprocedural language features for persons working in numerical mathematics and as an exploration of some of the language requirements of numerical mathematics for persons working in language development. The article discusses C++, Fortran 77, Fortran 90, Haskell, Lisp\/CLOS, Modula-3, Sather, and SML with respect to a variety of numerical analysis tasks: interpolation, optimization, array access and update, iteration, recursion, random number generation, and Gaussian elimination on sparse matrices."}