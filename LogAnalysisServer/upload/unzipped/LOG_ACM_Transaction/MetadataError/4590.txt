{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/24865","fieldValue":" The majority of hybrid languages are based on the assumption that discontinuities in differential variables at discrete events are modeled by explicit mappings. When there are algebraic equations restricting the allowed new values of the differential variables, explicit remapping of differential variables forces the modeler to solve the algebraic equations. To overcome this difficulty, hybrid languages use many different language elements. This article shows that only one language element is needed for this purpose: an unknown declaration, which allows the explicit declaration of a variable as unknown. The syntax and semantics of unknown declarations are discussed. Examples are given, using the Chi language, in which unknown declarations are used for modeling multi-body collision, steady-state initialization, and consistent initialization of higher index systems. It is also illustrated how the declaration of unknowns can help to clarify the structure of the system of equations, and how it can help the modeler detect structurally singular systems of equations."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/24865","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/24865","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/3404","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/3404","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/24866","fieldValue":"Wang, Chia-Li"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/24866","fieldValue":" When simulating queues in heavy traffic, estimators of quantities such as average delay in queue d converge slowly to their true values. This problem is exacerbated when interarrival and service distributions are irregular. For the GI\/G\/1 queue, delay moments can be expressed in terms of moments of idle period I. Instead of estimating d directly by a standard regenerative estimator that we call DD, a method we call DI estimates d from estimated moments of I. DI was investigated some time ago and shown to be much more efficient than DD in heavy traffic. We measure efficiency as the factor by which variance is reduced. For the GI\/G\/1 queue, we show how to generate a sequence of realized values of the equilibrium idle period, Ie, that are not independent and identically distributed, but have the correct statistical properties in the long run. We show how to use this sequence to construct a new estimator of d, called DE, and of higher moments of delay as well. When arrivals are irregular, we show that DE is more efficient than DI, in some cases by a large factor, independent of the traffic intensity. Comparing DE with DD, these factors multiply. For GI\/G\/c, we construct a control-variates estimator of average delay in queue dc that is efficient in heavy traffic. It uses DE to estimate the average delay for the corresponding fast single server. We compare the efficiency of this method with another method in the literature. For M\/G\/c, we use insensitivity to construct another control-variates estimator of dc. We compare the efficiency of this estimator with the two c-server estimators above."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/24866","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/24866","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/24867","fieldValue":" Developing a single embedded application involves a multitude of different development tools including several different simulators. Most tools use different abstractions, have their own formalisms to represent the system under development, utilize different input and output data formats, and have their own semantics. A unified environment that allows capturing the system in one place and one that drives all necessary simulators and analysis tools from this shared representation needs a common representation technology that must support several different abstractions and formalisms seamlessly. Describing the individual formalisms by metamodels and carefully composing them is the underlying technology behind MILAN, a Model-based Integrated Simulation Framework. MILAN is an extensible framework that supports multigranular simulation of embedded systems by seamlessly integrating existing simulators into a unified environment. Formal metamodels and explicit constraints define the domain-specific modeling language developed for MILAN that combines hierarchical, heterogeneous, parametric dataflow representation with strong data typing. Multiple modeling aspects separate orthogonal concepts. The language also allows the representation of the design space of the application, not just a point solution. Nonfunctional requirements are captured as formal, application-specific constraints. MILAN has integrated tool support for design-space exploration and pruning. The models are used to automatically configure the integrated functional simulators, high-level performance and power estimators, cycle-accurate performance simulators, and power-aware simulators. Simulation results are used to automatically update the system models. The article focuses on the modeling methodology and briefly describes how the integrated models are utilized in the framework."}