{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/19381","fieldValue":" Methods and an algorithm for computing the generalized Marcum Qâ\u20AC\u201Cfunction $(Q_Î¼(x,y)) and the complementary function (PÎ¼$(x,y)) are described. These functions appear in problems of different technical and scientific areas such as, for example, radar detection and communications, statistics, and probability theory, where they are called the noncentral chi-square or the noncentral gamma cumulative distribution functions. The algorithm for computing the Marcum functions combines different methods of evaluation in different regions: series expansions, integral representations, asymptotic expansions, and use of three-term homogeneous recurrence relations. A relative accuracy close to $10^âˆ\u201912 can be obtained in the parameter region (x,y,Î¼) âˆˆ [0,A] Ã\u2014[0,A] Ã\u2014 [1,A], A = 200, while for larger parameters the accuracy decreases (close to 10âˆ\u201911 for A = 1000 and close to 5 Ã\u2014 10âˆ\u201911$ for A = 10000)."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/19381","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/19381","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/19382","fieldValue":"Kirby, Robert M"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/19382","fieldValue":" In this article we present a compile-time algorithm, implemented using C++ template metaprogramming techniques, that minimizes the use of temporary storage when evaluating expressions. We present the basic building blocks of our algorithm---transformations that act locally on nodes of the expression parse tree---and demonstrate that the application of these local transformations generates a (nonunique) expression that requires a minimum number of temporary storage objects to evaluate. We discuss a C++ implementation of our algorithm using expression templates, and give results demonstrating the effectiveness of our approach."}{"fieldName":"dc.subject","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/19382","fieldValue":"C++"}{"fieldName":"dc.title","informationCode":"WARN_TEXT_LENGTH_LARGE","handle":"12345678_acm\/19382","fieldValue":"Algorithm 940: Optimal Accumulator-Based Expression Evaluation through the Use of Expression Templates"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/19382","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/19382","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/19383","fieldValue":" The hierarchical Tucker format is a storage-efficient scheme to approximate and represent tensors of possibly high order. This article presents a Matlab toolbox, along with the underlying methodology and algorithms, which provides a convenient way to work with this format. The toolbox not only allows for the efficient storage and manipulation of tensors in hierarchical Tucker format but also offers a set of tools for the development of higher-level algorithms. Several examples for the use of the toolbox are given."}