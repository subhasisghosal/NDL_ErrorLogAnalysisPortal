{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/7001","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/7001","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/7002","fieldValue":" In distributed development of modern systems, contracts play a vital role in ensuring interoperability of components and adherence to specifications. It is therefore often desirable to verify the satisfaction of an overall property represented as a contract, given the satisfaction of smaller properties also represented as contracts. When the verification result is negative, designers must face the issue of refining the subproperties and components. This is an instance of the classical synthesis problems: â\u20ACœcan we construct a model that satisfies some given specification?â\u20AC? In this work, we propose two strategies enabling designers to synthesize or refine a set of contracts so that their composition satisfies a given contract. We develop a generic algebraic method and show how it can be applied in different contract models to support top-down component-based development of distributed systems."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/7002","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/7002","fieldValue":"ACM"}{"fieldName":"dc.contributor.author","informationCode":"WARN_INVALID_PERSON","handle":"12345678_acm\/1009","fieldValue":"Choi, Jong-Deok"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/1009","fieldValue":" Data-flow analysis is a basis for program optimization and parallelizing transformations. The mechanism of passing reference parameters at call sites generates interprocedural aliases which complicate this analysis. Solutions have been developed for efficiently computing interprocedural aliases. However, factoring the computed aliases into data-flow information has been mostly overlooked, although improper factoring results in imprecise (conservative) data-flow information. In this document, we describe a mechanism which, in factoring in interprocedural aliases, computes data-flow information more precisely and with less time and space overhead than previous approaches."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/1009","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/1009","fieldValue":"ACM"}{"fieldName":"dc.relation.haspart","informationCode":"ERR_FORMAT_HASPART","handle":"12345678_acm\/1059","fieldValue":"[{\"visible\":false,\"sortKey\":\"January 2015\",\"expandable\":true,\"handle\":\"12345678_acm\/1096\",\"title\":\"Issue 4, January 2015\"},{\"visible\":false,\"sortKey\":\"December 2014\",\"expandable\":true,\"handle\":\"12345678_acm\/1095\",\"title\":\"Issue 4, December 2014\"},{\"visible\":false,\"sortKey\":\"October 2014\",\"expandable\":true,\"handle\":\"12345678_acm\/1094\",\"title\":\"Issue 3, October 2014\"},{\"visible\":false,\"sortKey\":\"July 2014\",\"expandable\":true,\"handle\":\"12345678_acm\/1093\",\"title\":\"Issue 2, July 2014\"},{\"visible\":false,\"sortKey\":\"March 2014\",\"expandable\":true,\"handle\":\"12345678_acm\/1092\",\"title\":\"Issue 1, March 2014\"}]"}