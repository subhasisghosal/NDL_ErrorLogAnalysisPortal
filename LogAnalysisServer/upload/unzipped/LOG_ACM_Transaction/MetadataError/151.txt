{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/11452","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/11452","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/11453","fieldValue":" We show how game semantics can be employed to prove that program equivalence in finitary Idealized Algol with active expressions is undecidable. We also investigate a notion of representability of languages by terms and show that finitary Idealized Algol terms of respectively second, third and higher orders define exactly regular, context-free and recursively enumerable languages."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/11453","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/11453","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/11454","fieldValue":" The degree sequence of an n-vertex graph is d0,â\u20AC¦,dnâˆ\u20191, where each di is the number of vertices of degree i in the graph. A random graph with degree sequence d0,â\u20AC¦,dnâˆ\u20191 is a randomly selected member of the set of graphs on &lcub;1,â\u20AC¦,n&rcub; with that degree sequence, all choices being equally likely. Let Î»0,Î»1,â\u20AC¦ be a sequence of nonnegative reals summing to 1. A class of finite graphs has degree sequences approximated by Î»0,Î»1,â\u20AC¦ if, for every i and n, the members of the class of size n have Î»i n &plus; o(n) vertices of degree i. Our main result is a convergence law for random graphs with degree sequences approximated by some sequence Î»0,Î»1,â\u20AC¦. With certain conditions on the sequence Î»0,Î»1,â\u20AC¦, the probability of any first-order sentence on random graphs of size n converges to a limit as n grows."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/11454","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/11454","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/2044","fieldValue":" Shared-memory programmers traditionally assumed Sequential Consistency (SC), but modern systems have relaxed memory consistency. Here, the trend in languages is toward Data-Race-Free (DRF) models, where, assuming annotated synchronizations and the program being well-synchronized by those synchronizations, the hardware and compiler guarantee SC. However, legacy programs lack annotations, so even well-synchronized (legacy DRF) programs arenâ\u20AC™t recognized. For legacy DRF programs, we can significantly prune the set of memory orderings determined by automated fence placement by automatically identifying synchronization reads. We prove our rules for identifying them conservatively, implement them within LLVM, and observe a 30&percnt; average performance improvement over previous techniques."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/2044","fieldValue":"ACM"}