{"fieldName":"dc.subject","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6420","fieldValue":"FPGA"}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/6420","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6420","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/6421","fieldValue":" Dynamic reconfiguration imposes significant penalties in terms of performance and energy. Scheduling the execution of tasks on a dynamically reconfigurable device is therefore of critical importance. Likewise, other application domains have cost models that are effectively the same as dynamic reconfiguration; examples include: data transmission across multiprocessor systems; dynamic code updating and reprogramming of motes in sensor networks; and module allocation, wherein the sharing of resources effectively eliminates inherent reconfiguration costs. This article contributes a fully polynomial time approximation algorithm for the problem of scheduling independent tasks onto a fixed number of heterogeneous reconfigurable resources, where each task has a different hardware and software latency on each device; the reconfiguration latencies can also vary between resources. A general-purpose processor and a field programmable gate array were used to experimentally validate the proposed technique using a pair of encryption algorithms. The latencies of the schedules obtained by the approximation scheme were at most 1.1Ã\u2014 longer than the optimal solution, which was found using integer linear programming; this result is better than the theoretical worst-case guarantee of the approximation algorithm, which was 1.999Ã\u2014. The length of the schedules obtained using list scheduling, a well-known polynomial time heuristic, were at most 2.6Ã\u2014 longer than optimal."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/6421","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6421","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/6422","fieldValue":" The difficult aspect of hardware reconfiguration is not creating the computational blocks, which are generally available from FPGA vendors and third parties, but linking the blocks in a manner that suits each application's unique connectivity, bandwidth, and latency requirements. Our approach uses the standard Xilinx implementation tools to generate dynamic module partial bitstreams, but choosing the module's coordinates and completing connections to other modules are runtime operations. Scripts automatically add interface wrappers to dynamic modules and generate a library of relocatable partial bitstreams. The library is used by an efficient runtime system that completes application requests for instancing and connecting modules, effectively insulating the designer from FPGA reconfiguration complexities. In this way, a large sandbox may be allocated to dynamic modules rather than fixed module slots and interconnect. Application engineers interact with the Wires on Demand (WoD) system through a runtime software API, and do not have to master hardware description languages and implementation tools."}{"fieldName":"dc.publisher","informationCode":"WARN_TEXT_LENGTH_SMALL","handle":"12345678_acm\/6422","fieldValue":"ACM"}{"fieldName":"dc.publisher","informationCode":"WARN_ALL_WORD_UPPER","handle":"12345678_acm\/6422","fieldValue":"ACM"}{"fieldName":"dc.description.abstract","informationCode":"ERR_SPACE_AT_EDGE","handle":"12345678_acm\/6423","fieldValue":" A packet-switched network architecture named Qnet and programming interface is presented that simplifies the integration of reconfigurable computing modules within a Field-Programmable Gate Array (FPGA). Qnet provides an abstraction layer to the designer of FPGA accelerator modules that hides the complexities of the system, while supporting a high degree of parallelism and performance. The architecture facilitates system design with pluggable, reusable modules. A network protocol is described that supports a three-party communication scheme between an initiator, a sender and a receiver. This protocol allows a master device to manage the state of other devices and the data flow within the system. An example using a high-level language is given. The Qnet architecture opens the computational power of FPGAs to computer scientists and software developers."}